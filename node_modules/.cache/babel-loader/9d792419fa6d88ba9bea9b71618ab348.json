{"ast":null,"code":"/**\n * Until SelectionRange lands in LSP, we'll return Range from server and convert it to\n * SelectionRange on client side\n */\nimport { Range, SelectionRange } from './../_deps/vscode-languageserver-types/main.js';\nimport { createScanner } from '../parser/htmlScanner.js';\nimport { parse } from '../parser/htmlParser.js';\nimport { TokenType } from '../htmlLanguageTypes.js';\nexport function getSelectionRanges(document, positions) {\n  function getSelectionRange(position) {\n    var applicableRanges = getApplicableRanges(document, position);\n    var prev = undefined;\n    var current = undefined;\n\n    for (var index = applicableRanges.length - 1; index >= 0; index--) {\n      var range = applicableRanges[index];\n\n      if (!prev || range[0] !== prev[0] || range[1] !== prev[1]) {\n        current = SelectionRange.create(Range.create(document.positionAt(applicableRanges[index][0]), document.positionAt(applicableRanges[index][1])), current);\n      }\n\n      prev = range;\n    }\n\n    if (!current) {\n      current = SelectionRange.create(Range.create(position, position));\n    }\n\n    return current;\n  }\n\n  return positions.map(getSelectionRange);\n}\n\nfunction getApplicableRanges(document, position) {\n  var htmlDoc = parse(document.getText());\n  var currOffset = document.offsetAt(position);\n  var currNode = htmlDoc.findNodeAt(currOffset);\n  var result = getAllParentTagRanges(currNode); // Self-closing or void elements\n\n  if (currNode.startTagEnd && !currNode.endTagStart) {\n    // THe rare case of unmatching tag pairs like <div></div1>\n    if (currNode.startTagEnd !== currNode.end) {\n      return [[currNode.start, currNode.end]];\n    }\n\n    var closeRange = Range.create(document.positionAt(currNode.startTagEnd - 2), document.positionAt(currNode.startTagEnd));\n    var closeText = document.getText(closeRange); // Self-closing element\n\n    if (closeText === '/>') {\n      result.unshift([currNode.start + 1, currNode.startTagEnd - 2]);\n    } // Void element\n    else {\n        result.unshift([currNode.start + 1, currNode.startTagEnd - 1]);\n      }\n\n    var attributeLevelRanges = getAttributeLevelRanges(document, currNode, currOffset);\n    result = attributeLevelRanges.concat(result);\n    return result;\n  }\n\n  if (!currNode.startTagEnd || !currNode.endTagStart) {\n    return result;\n  }\n  /**\n   * For html like\n   * `<div class=\"foo\">bar</div>`\n   */\n\n\n  result.unshift([currNode.start, currNode.end]);\n  /**\n   * Cursor inside `<div class=\"foo\">`\n   */\n\n  if (currNode.start < currOffset && currOffset < currNode.startTagEnd) {\n    result.unshift([currNode.start + 1, currNode.startTagEnd - 1]);\n    var attributeLevelRanges = getAttributeLevelRanges(document, currNode, currOffset);\n    result = attributeLevelRanges.concat(result);\n    return result;\n  }\n  /**\n   * Cursor inside `bar`\n   */\n  else if (currNode.startTagEnd <= currOffset && currOffset <= currNode.endTagStart) {\n      result.unshift([currNode.startTagEnd, currNode.endTagStart]);\n      return result;\n    }\n    /**\n     * Cursor inside `</div>`\n     */\n    else {\n        // `div` inside `</div>`\n        if (currOffset >= currNode.endTagStart + 2) {\n          result.unshift([currNode.endTagStart + 2, currNode.end - 1]);\n        }\n\n        return result;\n      }\n}\n\nfunction getAllParentTagRanges(initialNode) {\n  var currNode = initialNode;\n\n  var getNodeRanges = function (n) {\n    if (n.startTagEnd && n.endTagStart && n.startTagEnd < n.endTagStart) {\n      return [[n.startTagEnd, n.endTagStart], [n.start, n.end]];\n    }\n\n    return [[n.start, n.end]];\n  };\n\n  var result = [];\n\n  while (currNode.parent) {\n    currNode = currNode.parent;\n    getNodeRanges(currNode).forEach(function (r) {\n      return result.push(r);\n    });\n  }\n\n  return result;\n}\n\nfunction getAttributeLevelRanges(document, currNode, currOffset) {\n  var currNodeRange = Range.create(document.positionAt(currNode.start), document.positionAt(currNode.end));\n  var currNodeText = document.getText(currNodeRange);\n  var relativeOffset = currOffset - currNode.start;\n  /**\n   * Tag level semantic selection\n   */\n\n  var scanner = createScanner(currNodeText);\n  var token = scanner.scan();\n  /**\n   * For text like\n   * <div class=\"foo\">bar</div>\n   */\n\n  var positionOffset = currNode.start;\n  var result = [];\n  var isInsideAttribute = false;\n  var attrStart = -1;\n\n  while (token !== TokenType.EOS) {\n    switch (token) {\n      case TokenType.AttributeName:\n        {\n          if (relativeOffset < scanner.getTokenOffset()) {\n            isInsideAttribute = false;\n            break;\n          }\n\n          if (relativeOffset <= scanner.getTokenEnd()) {\n            // `class`\n            result.unshift([scanner.getTokenOffset(), scanner.getTokenEnd()]);\n          }\n\n          isInsideAttribute = true;\n          attrStart = scanner.getTokenOffset();\n          break;\n        }\n\n      case TokenType.AttributeValue:\n        {\n          if (!isInsideAttribute) {\n            break;\n          }\n\n          var valueText = scanner.getTokenText();\n\n          if (relativeOffset < scanner.getTokenOffset()) {\n            // `class=\"foo\"`\n            result.push([attrStart, scanner.getTokenEnd()]);\n            break;\n          }\n\n          if (relativeOffset >= scanner.getTokenOffset() && relativeOffset <= scanner.getTokenEnd()) {\n            // `\"foo\"`\n            result.unshift([scanner.getTokenOffset(), scanner.getTokenEnd()]); // `foo`\n\n            if (valueText[0] === \"\\\"\" && valueText[valueText.length - 1] === \"\\\"\" || valueText[0] === \"'\" && valueText[valueText.length - 1] === \"'\") {\n              if (relativeOffset >= scanner.getTokenOffset() + 1 && relativeOffset <= scanner.getTokenEnd() - 1) {\n                result.unshift([scanner.getTokenOffset() + 1, scanner.getTokenEnd() - 1]);\n              }\n            } // `class=\"foo\"`\n\n\n            result.push([attrStart, scanner.getTokenEnd()]);\n          }\n\n          break;\n        }\n    }\n\n    token = scanner.scan();\n  }\n\n  return result.map(function (pair) {\n    return [pair[0] + positionOffset, pair[1] + positionOffset];\n  });\n}","map":{"version":3,"sources":["/home/chaithra/Documents/customised/customised/node_modules/monaco-editor/esm/vs/language/html/_deps/vscode-html-languageservice/services/htmlSelectionRange.js"],"names":["Range","SelectionRange","createScanner","parse","TokenType","getSelectionRanges","document","positions","getSelectionRange","position","applicableRanges","getApplicableRanges","prev","undefined","current","index","length","range","create","positionAt","map","htmlDoc","getText","currOffset","offsetAt","currNode","findNodeAt","result","getAllParentTagRanges","startTagEnd","endTagStart","end","start","closeRange","closeText","unshift","attributeLevelRanges","getAttributeLevelRanges","concat","initialNode","getNodeRanges","n","parent","forEach","r","push","currNodeRange","currNodeText","relativeOffset","scanner","token","scan","positionOffset","isInsideAttribute","attrStart","EOS","AttributeName","getTokenOffset","getTokenEnd","AttributeValue","valueText","getTokenText","pair"],"mappings":"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","sourcesContent":["/**\n * Until SelectionRange lands in LSP, we'll return Range from server and convert it to\n * SelectionRange on client side\n */\nimport { Range, SelectionRange } from './../_deps/vscode-languageserver-types/main.js';\nimport { createScanner } from '../parser/htmlScanner.js';\nimport { parse } from '../parser/htmlParser.js';\nimport { TokenType } from '../htmlLanguageTypes.js';\nexport function getSelectionRanges(document, positions) {\n    function getSelectionRange(position) {\n        var applicableRanges = getApplicableRanges(document, position);\n        var prev = undefined;\n        var current = undefined;\n        for (var index = applicableRanges.length - 1; index >= 0; index--) {\n            var range = applicableRanges[index];\n            if (!prev || range[0] !== prev[0] || range[1] !== prev[1]) {\n                current = SelectionRange.create(Range.create(document.positionAt(applicableRanges[index][0]), document.positionAt(applicableRanges[index][1])), current);\n            }\n            prev = range;\n        }\n        if (!current) {\n            current = SelectionRange.create(Range.create(position, position));\n        }\n        return current;\n    }\n    return positions.map(getSelectionRange);\n}\nfunction getApplicableRanges(document, position) {\n    var htmlDoc = parse(document.getText());\n    var currOffset = document.offsetAt(position);\n    var currNode = htmlDoc.findNodeAt(currOffset);\n    var result = getAllParentTagRanges(currNode);\n    // Self-closing or void elements\n    if (currNode.startTagEnd && !currNode.endTagStart) {\n        // THe rare case of unmatching tag pairs like <div></div1>\n        if (currNode.startTagEnd !== currNode.end) {\n            return [[currNode.start, currNode.end]];\n        }\n        var closeRange = Range.create(document.positionAt(currNode.startTagEnd - 2), document.positionAt(currNode.startTagEnd));\n        var closeText = document.getText(closeRange);\n        // Self-closing element\n        if (closeText === '/>') {\n            result.unshift([currNode.start + 1, currNode.startTagEnd - 2]);\n        }\n        // Void element\n        else {\n            result.unshift([currNode.start + 1, currNode.startTagEnd - 1]);\n        }\n        var attributeLevelRanges = getAttributeLevelRanges(document, currNode, currOffset);\n        result = attributeLevelRanges.concat(result);\n        return result;\n    }\n    if (!currNode.startTagEnd || !currNode.endTagStart) {\n        return result;\n    }\n    /**\n     * For html like\n     * `<div class=\"foo\">bar</div>`\n     */\n    result.unshift([currNode.start, currNode.end]);\n    /**\n     * Cursor inside `<div class=\"foo\">`\n     */\n    if (currNode.start < currOffset && currOffset < currNode.startTagEnd) {\n        result.unshift([currNode.start + 1, currNode.startTagEnd - 1]);\n        var attributeLevelRanges = getAttributeLevelRanges(document, currNode, currOffset);\n        result = attributeLevelRanges.concat(result);\n        return result;\n    }\n    /**\n     * Cursor inside `bar`\n     */\n    else if (currNode.startTagEnd <= currOffset && currOffset <= currNode.endTagStart) {\n        result.unshift([currNode.startTagEnd, currNode.endTagStart]);\n        return result;\n    }\n    /**\n     * Cursor inside `</div>`\n     */\n    else {\n        // `div` inside `</div>`\n        if (currOffset >= currNode.endTagStart + 2) {\n            result.unshift([currNode.endTagStart + 2, currNode.end - 1]);\n        }\n        return result;\n    }\n}\nfunction getAllParentTagRanges(initialNode) {\n    var currNode = initialNode;\n    var getNodeRanges = function (n) {\n        if (n.startTagEnd && n.endTagStart && n.startTagEnd < n.endTagStart) {\n            return [\n                [n.startTagEnd, n.endTagStart],\n                [n.start, n.end]\n            ];\n        }\n        return [\n            [n.start, n.end]\n        ];\n    };\n    var result = [];\n    while (currNode.parent) {\n        currNode = currNode.parent;\n        getNodeRanges(currNode).forEach(function (r) { return result.push(r); });\n    }\n    return result;\n}\nfunction getAttributeLevelRanges(document, currNode, currOffset) {\n    var currNodeRange = Range.create(document.positionAt(currNode.start), document.positionAt(currNode.end));\n    var currNodeText = document.getText(currNodeRange);\n    var relativeOffset = currOffset - currNode.start;\n    /**\n     * Tag level semantic selection\n     */\n    var scanner = createScanner(currNodeText);\n    var token = scanner.scan();\n    /**\n     * For text like\n     * <div class=\"foo\">bar</div>\n     */\n    var positionOffset = currNode.start;\n    var result = [];\n    var isInsideAttribute = false;\n    var attrStart = -1;\n    while (token !== TokenType.EOS) {\n        switch (token) {\n            case TokenType.AttributeName: {\n                if (relativeOffset < scanner.getTokenOffset()) {\n                    isInsideAttribute = false;\n                    break;\n                }\n                if (relativeOffset <= scanner.getTokenEnd()) {\n                    // `class`\n                    result.unshift([scanner.getTokenOffset(), scanner.getTokenEnd()]);\n                }\n                isInsideAttribute = true;\n                attrStart = scanner.getTokenOffset();\n                break;\n            }\n            case TokenType.AttributeValue: {\n                if (!isInsideAttribute) {\n                    break;\n                }\n                var valueText = scanner.getTokenText();\n                if (relativeOffset < scanner.getTokenOffset()) {\n                    // `class=\"foo\"`\n                    result.push([attrStart, scanner.getTokenEnd()]);\n                    break;\n                }\n                if (relativeOffset >= scanner.getTokenOffset() && relativeOffset <= scanner.getTokenEnd()) {\n                    // `\"foo\"`\n                    result.unshift([scanner.getTokenOffset(), scanner.getTokenEnd()]);\n                    // `foo`\n                    if ((valueText[0] === \"\\\"\" && valueText[valueText.length - 1] === \"\\\"\") || (valueText[0] === \"'\" && valueText[valueText.length - 1] === \"'\")) {\n                        if (relativeOffset >= scanner.getTokenOffset() + 1 && relativeOffset <= scanner.getTokenEnd() - 1) {\n                            result.unshift([scanner.getTokenOffset() + 1, scanner.getTokenEnd() - 1]);\n                        }\n                    }\n                    // `class=\"foo\"`\n                    result.push([attrStart, scanner.getTokenEnd()]);\n                }\n                break;\n            }\n        }\n        token = scanner.scan();\n    }\n    return result.map(function (pair) {\n        return [pair[0] + positionOffset, pair[1] + positionOffset];\n    });\n}\n"]},"metadata":{},"sourceType":"module"}