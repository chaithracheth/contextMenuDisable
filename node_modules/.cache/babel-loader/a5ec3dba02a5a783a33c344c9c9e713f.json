{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n'use strict';\n\nimport { TokenType, Scanner } from '../parser/cssScanner.js';\nimport { SCSSScanner, InterpolationFunction } from '../parser/scssScanner.js';\nimport { LESSScanner } from '../parser/lessScanner.js';\nexport function getFoldingRanges(document, context) {\n  var ranges = computeFoldingRanges(document);\n  return limitFoldingRanges(ranges, context);\n}\n\nfunction computeFoldingRanges(document) {\n  function getStartLine(t) {\n    return document.positionAt(t.offset).line;\n  }\n\n  function getEndLine(t) {\n    return document.positionAt(t.offset + t.len).line;\n  }\n\n  function getScanner() {\n    switch (document.languageId) {\n      case 'scss':\n        return new SCSSScanner();\n\n      case 'less':\n        return new LESSScanner();\n\n      default:\n        return new Scanner();\n    }\n  }\n\n  function tokenToRange(t, kind) {\n    var startLine = getStartLine(t);\n    var endLine = getEndLine(t);\n\n    if (startLine !== endLine) {\n      return {\n        startLine: startLine,\n        endLine: endLine,\n        kind: kind\n      };\n    } else {\n      return null;\n    }\n  }\n\n  var ranges = [];\n  var delimiterStack = [];\n  var scanner = getScanner();\n  scanner.ignoreComment = false;\n  scanner.setSource(document.getText());\n  var token = scanner.scan();\n  var prevToken = null;\n\n  var _loop_1 = function () {\n    switch (token.type) {\n      case TokenType.CurlyL:\n      case InterpolationFunction:\n        {\n          delimiterStack.push({\n            line: getStartLine(token),\n            type: 'brace',\n            isStart: true\n          });\n          break;\n        }\n\n      case TokenType.CurlyR:\n        {\n          if (delimiterStack.length !== 0) {\n            var prevDelimiter = popPrevStartDelimiterOfType(delimiterStack, 'brace');\n\n            if (!prevDelimiter) {\n              break;\n            }\n\n            var endLine = getEndLine(token);\n\n            if (prevDelimiter.type === 'brace') {\n              /**\n               * Other than the case when curly brace is not on a new line by itself, for example\n               * .foo {\n               *   color: red; }\n               * Use endLine minus one to show ending curly brace\n               */\n              if (prevToken && getEndLine(prevToken) !== endLine) {\n                endLine--;\n              }\n\n              if (prevDelimiter.line !== endLine) {\n                ranges.push({\n                  startLine: prevDelimiter.line,\n                  endLine: endLine,\n                  kind: undefined\n                });\n              }\n            }\n          }\n\n          break;\n        }\n\n      /**\n       * In CSS, there is no single line comment prefixed with //\n       * All comments are marked as `Comment`\n       */\n\n      case TokenType.Comment:\n        {\n          var commentRegionMarkerToDelimiter_1 = function (marker) {\n            if (marker === '#region') {\n              return {\n                line: getStartLine(token),\n                type: 'comment',\n                isStart: true\n              };\n            } else {\n              return {\n                line: getEndLine(token),\n                type: 'comment',\n                isStart: false\n              };\n            }\n          };\n\n          var getCurrDelimiter = function (token) {\n            var matches = token.text.match(/^\\s*\\/\\*\\s*(#region|#endregion)\\b\\s*(.*?)\\s*\\*\\//);\n\n            if (matches) {\n              return commentRegionMarkerToDelimiter_1(matches[1]);\n            } else if (document.languageId === 'scss' || document.languageId === 'less') {\n              var matches_1 = token.text.match(/^\\s*\\/\\/\\s*(#region|#endregion)\\b\\s*(.*?)\\s*/);\n\n              if (matches_1) {\n                return commentRegionMarkerToDelimiter_1(matches_1[1]);\n              }\n            }\n\n            return null;\n          };\n\n          var currDelimiter = getCurrDelimiter(token); // /* */ comment region folding\n          // All #region and #endregion cases\n\n          if (currDelimiter) {\n            if (currDelimiter.isStart) {\n              delimiterStack.push(currDelimiter);\n            } else {\n              var prevDelimiter = popPrevStartDelimiterOfType(delimiterStack, 'comment');\n\n              if (!prevDelimiter) {\n                break;\n              }\n\n              if (prevDelimiter.type === 'comment') {\n                if (prevDelimiter.line !== currDelimiter.line) {\n                  ranges.push({\n                    startLine: prevDelimiter.line,\n                    endLine: currDelimiter.line,\n                    kind: 'region'\n                  });\n                }\n              }\n            }\n          } // Multiline comment case\n          else {\n              var range = tokenToRange(token, 'comment');\n\n              if (range) {\n                ranges.push(range);\n              }\n            }\n\n          break;\n        }\n    }\n\n    prevToken = token;\n    token = scanner.scan();\n  };\n\n  while (token.type !== TokenType.EOF) {\n    _loop_1();\n  }\n\n  return ranges;\n}\n\nfunction popPrevStartDelimiterOfType(stack, type) {\n  if (stack.length === 0) {\n    return null;\n  }\n\n  for (var i = stack.length - 1; i >= 0; i--) {\n    if (stack[i].type === type && stack[i].isStart) {\n      return stack.splice(i, 1)[0];\n    }\n  }\n\n  return null;\n}\n/**\n * - Sort regions\n * - Remove invalid regions (intersections)\n * - If limit exceeds, only return `rangeLimit` amount of ranges\n */\n\n\nfunction limitFoldingRanges(ranges, context) {\n  var maxRanges = context && context.rangeLimit || Number.MAX_VALUE;\n  var sortedRanges = ranges.sort(function (r1, r2) {\n    var diff = r1.startLine - r2.startLine;\n\n    if (diff === 0) {\n      diff = r1.endLine - r2.endLine;\n    }\n\n    return diff;\n  });\n  var validRanges = [];\n  var prevEndLine = -1;\n  sortedRanges.forEach(function (r) {\n    if (!(r.startLine < prevEndLine && prevEndLine < r.endLine)) {\n      validRanges.push(r);\n      prevEndLine = r.endLine;\n    }\n  });\n\n  if (validRanges.length < maxRanges) {\n    return validRanges;\n  } else {\n    return validRanges.slice(0, maxRanges);\n  }\n}","map":{"version":3,"sources":["/home/chaithra/Documents/customised/customised/node_modules/monaco-editor/esm/vs/language/css/_deps/vscode-css-languageservice/services/cssFolding.js"],"names":["TokenType","Scanner","SCSSScanner","InterpolationFunction","LESSScanner","getFoldingRanges","document","context","ranges","computeFoldingRanges","limitFoldingRanges","getStartLine","t","positionAt","offset","line","getEndLine","len","getScanner","languageId","tokenToRange","kind","startLine","endLine","delimiterStack","scanner","ignoreComment","setSource","getText","token","scan","prevToken","_loop_1","type","CurlyL","push","isStart","CurlyR","length","prevDelimiter","popPrevStartDelimiterOfType","undefined","Comment","commentRegionMarkerToDelimiter_1","marker","getCurrDelimiter","matches","text","match","matches_1","currDelimiter","range","EOF","stack","i","splice","maxRanges","rangeLimit","Number","MAX_VALUE","sortedRanges","sort","r1","r2","diff","validRanges","prevEndLine","forEach","r","slice"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n'use strict';\nimport { TokenType, Scanner } from '../parser/cssScanner.js';\nimport { SCSSScanner, InterpolationFunction } from '../parser/scssScanner.js';\nimport { LESSScanner } from '../parser/lessScanner.js';\nexport function getFoldingRanges(document, context) {\n    var ranges = computeFoldingRanges(document);\n    return limitFoldingRanges(ranges, context);\n}\nfunction computeFoldingRanges(document) {\n    function getStartLine(t) {\n        return document.positionAt(t.offset).line;\n    }\n    function getEndLine(t) {\n        return document.positionAt(t.offset + t.len).line;\n    }\n    function getScanner() {\n        switch (document.languageId) {\n            case 'scss':\n                return new SCSSScanner();\n            case 'less':\n                return new LESSScanner();\n            default:\n                return new Scanner();\n        }\n    }\n    function tokenToRange(t, kind) {\n        var startLine = getStartLine(t);\n        var endLine = getEndLine(t);\n        if (startLine !== endLine) {\n            return {\n                startLine: startLine,\n                endLine: endLine,\n                kind: kind\n            };\n        }\n        else {\n            return null;\n        }\n    }\n    var ranges = [];\n    var delimiterStack = [];\n    var scanner = getScanner();\n    scanner.ignoreComment = false;\n    scanner.setSource(document.getText());\n    var token = scanner.scan();\n    var prevToken = null;\n    var _loop_1 = function () {\n        switch (token.type) {\n            case TokenType.CurlyL:\n            case InterpolationFunction:\n                {\n                    delimiterStack.push({ line: getStartLine(token), type: 'brace', isStart: true });\n                    break;\n                }\n            case TokenType.CurlyR: {\n                if (delimiterStack.length !== 0) {\n                    var prevDelimiter = popPrevStartDelimiterOfType(delimiterStack, 'brace');\n                    if (!prevDelimiter) {\n                        break;\n                    }\n                    var endLine = getEndLine(token);\n                    if (prevDelimiter.type === 'brace') {\n                        /**\n                         * Other than the case when curly brace is not on a new line by itself, for example\n                         * .foo {\n                         *   color: red; }\n                         * Use endLine minus one to show ending curly brace\n                         */\n                        if (prevToken && getEndLine(prevToken) !== endLine) {\n                            endLine--;\n                        }\n                        if (prevDelimiter.line !== endLine) {\n                            ranges.push({\n                                startLine: prevDelimiter.line,\n                                endLine: endLine,\n                                kind: undefined\n                            });\n                        }\n                    }\n                }\n                break;\n            }\n            /**\n             * In CSS, there is no single line comment prefixed with //\n             * All comments are marked as `Comment`\n             */\n            case TokenType.Comment: {\n                var commentRegionMarkerToDelimiter_1 = function (marker) {\n                    if (marker === '#region') {\n                        return { line: getStartLine(token), type: 'comment', isStart: true };\n                    }\n                    else {\n                        return { line: getEndLine(token), type: 'comment', isStart: false };\n                    }\n                };\n                var getCurrDelimiter = function (token) {\n                    var matches = token.text.match(/^\\s*\\/\\*\\s*(#region|#endregion)\\b\\s*(.*?)\\s*\\*\\//);\n                    if (matches) {\n                        return commentRegionMarkerToDelimiter_1(matches[1]);\n                    }\n                    else if (document.languageId === 'scss' || document.languageId === 'less') {\n                        var matches_1 = token.text.match(/^\\s*\\/\\/\\s*(#region|#endregion)\\b\\s*(.*?)\\s*/);\n                        if (matches_1) {\n                            return commentRegionMarkerToDelimiter_1(matches_1[1]);\n                        }\n                    }\n                    return null;\n                };\n                var currDelimiter = getCurrDelimiter(token);\n                // /* */ comment region folding\n                // All #region and #endregion cases\n                if (currDelimiter) {\n                    if (currDelimiter.isStart) {\n                        delimiterStack.push(currDelimiter);\n                    }\n                    else {\n                        var prevDelimiter = popPrevStartDelimiterOfType(delimiterStack, 'comment');\n                        if (!prevDelimiter) {\n                            break;\n                        }\n                        if (prevDelimiter.type === 'comment') {\n                            if (prevDelimiter.line !== currDelimiter.line) {\n                                ranges.push({\n                                    startLine: prevDelimiter.line,\n                                    endLine: currDelimiter.line,\n                                    kind: 'region'\n                                });\n                            }\n                        }\n                    }\n                }\n                // Multiline comment case\n                else {\n                    var range = tokenToRange(token, 'comment');\n                    if (range) {\n                        ranges.push(range);\n                    }\n                }\n                break;\n            }\n        }\n        prevToken = token;\n        token = scanner.scan();\n    };\n    while (token.type !== TokenType.EOF) {\n        _loop_1();\n    }\n    return ranges;\n}\nfunction popPrevStartDelimiterOfType(stack, type) {\n    if (stack.length === 0) {\n        return null;\n    }\n    for (var i = stack.length - 1; i >= 0; i--) {\n        if (stack[i].type === type && stack[i].isStart) {\n            return stack.splice(i, 1)[0];\n        }\n    }\n    return null;\n}\n/**\n * - Sort regions\n * - Remove invalid regions (intersections)\n * - If limit exceeds, only return `rangeLimit` amount of ranges\n */\nfunction limitFoldingRanges(ranges, context) {\n    var maxRanges = context && context.rangeLimit || Number.MAX_VALUE;\n    var sortedRanges = ranges.sort(function (r1, r2) {\n        var diff = r1.startLine - r2.startLine;\n        if (diff === 0) {\n            diff = r1.endLine - r2.endLine;\n        }\n        return diff;\n    });\n    var validRanges = [];\n    var prevEndLine = -1;\n    sortedRanges.forEach(function (r) {\n        if (!(r.startLine < prevEndLine && prevEndLine < r.endLine)) {\n            validRanges.push(r);\n            prevEndLine = r.endLine;\n        }\n    });\n    if (validRanges.length < maxRanges) {\n        return validRanges;\n    }\n    else {\n        return validRanges.slice(0, maxRanges);\n    }\n}\n"]},"metadata":{},"sourceType":"module"}