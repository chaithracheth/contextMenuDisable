{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n'use strict';\n\nexport function startsWith(haystack, needle) {\n  if (haystack.length < needle.length) {\n    return false;\n  }\n\n  for (var i = 0; i < needle.length; i++) {\n    if (haystack[i] !== needle[i]) {\n      return false;\n    }\n  }\n\n  return true;\n}\n/**\n * Determines if haystack ends with needle.\n */\n\nexport function endsWith(haystack, needle) {\n  var diff = haystack.length - needle.length;\n\n  if (diff > 0) {\n    return haystack.lastIndexOf(needle) === diff;\n  } else if (diff === 0) {\n    return haystack === needle;\n  } else {\n    return false;\n  }\n}\n/**\n * Computes the difference score for two strings. More similar strings have a higher score.\n * We use largest common subsequence dynamic programming approach but penalize in the end for length differences.\n * Strings that have a large length difference will get a bad default score 0.\n * Complexity - both time and space O(first.length * second.length)\n * Dynamic programming LCS computation http://en.wikipedia.org/wiki/Longest_common_subsequence_problem\n *\n * @param first a string\n * @param second a string\n */\n\nexport function difference(first, second, maxLenDelta) {\n  if (maxLenDelta === void 0) {\n    maxLenDelta = 4;\n  }\n\n  var lengthDifference = Math.abs(first.length - second.length); // We only compute score if length of the currentWord and length of entry.name are similar.\n\n  if (lengthDifference > maxLenDelta) {\n    return 0;\n  } // Initialize LCS (largest common subsequence) matrix.\n\n\n  var LCS = [];\n  var zeroArray = [];\n  var i, j;\n\n  for (i = 0; i < second.length + 1; ++i) {\n    zeroArray.push(0);\n  }\n\n  for (i = 0; i < first.length + 1; ++i) {\n    LCS.push(zeroArray);\n  }\n\n  for (i = 1; i < first.length + 1; ++i) {\n    for (j = 1; j < second.length + 1; ++j) {\n      if (first[i - 1] === second[j - 1]) {\n        LCS[i][j] = LCS[i - 1][j - 1] + 1;\n      } else {\n        LCS[i][j] = Math.max(LCS[i - 1][j], LCS[i][j - 1]);\n      }\n    }\n  }\n\n  return LCS[first.length][second.length] - Math.sqrt(lengthDifference);\n}\n/**\n * Limit of string length.\n */\n\nexport function getLimitedString(str, ellipsis) {\n  if (ellipsis === void 0) {\n    ellipsis = true;\n  }\n\n  if (!str) {\n    return '';\n  }\n\n  if (str.length < 140) {\n    return str;\n  }\n\n  return str.slice(0, 140) + (ellipsis ? '\\u2026' : '');\n}","map":{"version":3,"sources":["/home/chaithra/Documents/customised/customised/node_modules/monaco-editor/esm/vs/language/css/_deps/vscode-css-languageservice/utils/strings.js"],"names":["startsWith","haystack","needle","length","i","endsWith","diff","lastIndexOf","difference","first","second","maxLenDelta","lengthDifference","Math","abs","LCS","zeroArray","j","push","max","sqrt","getLimitedString","str","ellipsis","slice"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n'use strict';\nexport function startsWith(haystack, needle) {\n    if (haystack.length < needle.length) {\n        return false;\n    }\n    for (var i = 0; i < needle.length; i++) {\n        if (haystack[i] !== needle[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n/**\n * Determines if haystack ends with needle.\n */\nexport function endsWith(haystack, needle) {\n    var diff = haystack.length - needle.length;\n    if (diff > 0) {\n        return haystack.lastIndexOf(needle) === diff;\n    }\n    else if (diff === 0) {\n        return haystack === needle;\n    }\n    else {\n        return false;\n    }\n}\n/**\n * Computes the difference score for two strings. More similar strings have a higher score.\n * We use largest common subsequence dynamic programming approach but penalize in the end for length differences.\n * Strings that have a large length difference will get a bad default score 0.\n * Complexity - both time and space O(first.length * second.length)\n * Dynamic programming LCS computation http://en.wikipedia.org/wiki/Longest_common_subsequence_problem\n *\n * @param first a string\n * @param second a string\n */\nexport function difference(first, second, maxLenDelta) {\n    if (maxLenDelta === void 0) { maxLenDelta = 4; }\n    var lengthDifference = Math.abs(first.length - second.length);\n    // We only compute score if length of the currentWord and length of entry.name are similar.\n    if (lengthDifference > maxLenDelta) {\n        return 0;\n    }\n    // Initialize LCS (largest common subsequence) matrix.\n    var LCS = [];\n    var zeroArray = [];\n    var i, j;\n    for (i = 0; i < second.length + 1; ++i) {\n        zeroArray.push(0);\n    }\n    for (i = 0; i < first.length + 1; ++i) {\n        LCS.push(zeroArray);\n    }\n    for (i = 1; i < first.length + 1; ++i) {\n        for (j = 1; j < second.length + 1; ++j) {\n            if (first[i - 1] === second[j - 1]) {\n                LCS[i][j] = LCS[i - 1][j - 1] + 1;\n            }\n            else {\n                LCS[i][j] = Math.max(LCS[i - 1][j], LCS[i][j - 1]);\n            }\n        }\n    }\n    return LCS[first.length][second.length] - Math.sqrt(lengthDifference);\n}\n/**\n * Limit of string length.\n */\nexport function getLimitedString(str, ellipsis) {\n    if (ellipsis === void 0) { ellipsis = true; }\n    if (!str) {\n        return '';\n    }\n    if (str.length < 140) {\n        return str;\n    }\n    return str.slice(0, 140) + (ellipsis ? '\\u2026' : '');\n}\n"]},"metadata":{},"sourceType":"module"}