{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { createScanner } from './htmlScanner.js';\nimport { findFirst } from '../utils/arrays.js';\nimport { TokenType } from '../htmlLanguageTypes.js';\nimport { isVoidElement } from '../languageFacts/fact.js';\n\nvar Node =\n/** @class */\nfunction () {\n  function Node(start, end, children, parent) {\n    this.start = start;\n    this.end = end;\n    this.children = children;\n    this.parent = parent;\n    this.closed = false;\n  }\n\n  Object.defineProperty(Node.prototype, \"attributeNames\", {\n    get: function () {\n      return this.attributes ? Object.keys(this.attributes) : [];\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  Node.prototype.isSameTag = function (tagInLowerCase) {\n    return this.tag && tagInLowerCase && this.tag.length === tagInLowerCase.length && this.tag.toLowerCase() === tagInLowerCase;\n  };\n\n  Object.defineProperty(Node.prototype, \"firstChild\", {\n    get: function () {\n      return this.children[0];\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Node.prototype, \"lastChild\", {\n    get: function () {\n      return this.children.length ? this.children[this.children.length - 1] : void 0;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  Node.prototype.findNodeBefore = function (offset) {\n    var idx = findFirst(this.children, function (c) {\n      return offset <= c.start;\n    }) - 1;\n\n    if (idx >= 0) {\n      var child = this.children[idx];\n\n      if (offset > child.start) {\n        if (offset < child.end) {\n          return child.findNodeBefore(offset);\n        }\n\n        var lastChild = child.lastChild;\n\n        if (lastChild && lastChild.end === child.end) {\n          return child.findNodeBefore(offset);\n        }\n\n        return child;\n      }\n    }\n\n    return this;\n  };\n\n  Node.prototype.findNodeAt = function (offset) {\n    var idx = findFirst(this.children, function (c) {\n      return offset <= c.start;\n    }) - 1;\n\n    if (idx >= 0) {\n      var child = this.children[idx];\n\n      if (offset > child.start && offset <= child.end) {\n        return child.findNodeAt(offset);\n      }\n    }\n\n    return this;\n  };\n\n  return Node;\n}();\n\nexport { Node };\nexport function parse(text) {\n  var scanner = createScanner(text);\n  var htmlDocument = new Node(0, text.length, [], void 0);\n  var curr = htmlDocument;\n  var endTagStart = -1;\n  var endTagName = null;\n  var pendingAttribute = null;\n  var token = scanner.scan();\n\n  while (token !== TokenType.EOS) {\n    switch (token) {\n      case TokenType.StartTagOpen:\n        var child = new Node(scanner.getTokenOffset(), text.length, [], curr);\n        curr.children.push(child);\n        curr = child;\n        break;\n\n      case TokenType.StartTag:\n        curr.tag = scanner.getTokenText();\n        break;\n\n      case TokenType.StartTagClose:\n        curr.end = scanner.getTokenEnd(); // might be later set to end tag position\n\n        curr.startTagEnd = scanner.getTokenEnd();\n\n        if (curr.tag && isVoidElement(curr.tag) && curr.parent) {\n          curr.closed = true;\n          curr = curr.parent;\n        }\n\n        break;\n\n      case TokenType.StartTagSelfClose:\n        if (curr.parent) {\n          curr.closed = true;\n          curr.end = scanner.getTokenEnd();\n          curr.startTagEnd = scanner.getTokenEnd();\n          curr = curr.parent;\n        }\n\n        break;\n\n      case TokenType.EndTagOpen:\n        endTagStart = scanner.getTokenOffset();\n        endTagName = null;\n        break;\n\n      case TokenType.EndTag:\n        endTagName = scanner.getTokenText().toLowerCase();\n        break;\n\n      case TokenType.EndTagClose:\n        if (endTagName) {\n          var node = curr; // see if we can find a matching tag\n\n          while (!node.isSameTag(endTagName) && node.parent) {\n            node = node.parent;\n          }\n\n          if (node.parent) {\n            while (curr !== node) {\n              curr.end = endTagStart;\n              curr.closed = false;\n              curr = curr.parent;\n            }\n\n            curr.closed = true;\n            curr.endTagStart = endTagStart;\n            curr.end = scanner.getTokenEnd();\n            curr = curr.parent;\n          }\n        }\n\n        break;\n\n      case TokenType.AttributeName:\n        {\n          pendingAttribute = scanner.getTokenText();\n          var attributes = curr.attributes;\n\n          if (!attributes) {\n            curr.attributes = attributes = {};\n          }\n\n          attributes[pendingAttribute] = null; // Support valueless attributes such as 'checked'\n\n          break;\n        }\n\n      case TokenType.AttributeValue:\n        {\n          var value = scanner.getTokenText();\n          var attributes = curr.attributes;\n\n          if (attributes && pendingAttribute) {\n            attributes[pendingAttribute] = value;\n            pendingAttribute = null;\n          }\n\n          break;\n        }\n    }\n\n    token = scanner.scan();\n  }\n\n  while (curr.parent) {\n    curr.end = text.length;\n    curr.closed = false;\n    curr = curr.parent;\n  }\n\n  return {\n    roots: htmlDocument.children,\n    findNodeBefore: htmlDocument.findNodeBefore.bind(htmlDocument),\n    findNodeAt: htmlDocument.findNodeAt.bind(htmlDocument)\n  };\n}","map":{"version":3,"sources":["/home/chaithra/Documents/customised/customised/node_modules/monaco-editor/esm/vs/language/html/_deps/vscode-html-languageservice/parser/htmlParser.js"],"names":["createScanner","findFirst","TokenType","isVoidElement","Node","start","end","children","parent","closed","Object","defineProperty","prototype","get","attributes","keys","enumerable","configurable","isSameTag","tagInLowerCase","tag","length","toLowerCase","findNodeBefore","offset","idx","c","child","lastChild","findNodeAt","parse","text","scanner","htmlDocument","curr","endTagStart","endTagName","pendingAttribute","token","scan","EOS","StartTagOpen","getTokenOffset","push","StartTag","getTokenText","StartTagClose","getTokenEnd","startTagEnd","StartTagSelfClose","EndTagOpen","EndTag","EndTagClose","node","AttributeName","AttributeValue","value","roots","bind"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { createScanner } from './htmlScanner.js';\nimport { findFirst } from '../utils/arrays.js';\nimport { TokenType } from '../htmlLanguageTypes.js';\nimport { isVoidElement } from '../languageFacts/fact.js';\nvar Node = /** @class */ (function () {\n    function Node(start, end, children, parent) {\n        this.start = start;\n        this.end = end;\n        this.children = children;\n        this.parent = parent;\n        this.closed = false;\n    }\n    Object.defineProperty(Node.prototype, \"attributeNames\", {\n        get: function () { return this.attributes ? Object.keys(this.attributes) : []; },\n        enumerable: true,\n        configurable: true\n    });\n    Node.prototype.isSameTag = function (tagInLowerCase) {\n        return this.tag && tagInLowerCase && this.tag.length === tagInLowerCase.length && this.tag.toLowerCase() === tagInLowerCase;\n    };\n    Object.defineProperty(Node.prototype, \"firstChild\", {\n        get: function () { return this.children[0]; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Node.prototype, \"lastChild\", {\n        get: function () { return this.children.length ? this.children[this.children.length - 1] : void 0; },\n        enumerable: true,\n        configurable: true\n    });\n    Node.prototype.findNodeBefore = function (offset) {\n        var idx = findFirst(this.children, function (c) { return offset <= c.start; }) - 1;\n        if (idx >= 0) {\n            var child = this.children[idx];\n            if (offset > child.start) {\n                if (offset < child.end) {\n                    return child.findNodeBefore(offset);\n                }\n                var lastChild = child.lastChild;\n                if (lastChild && lastChild.end === child.end) {\n                    return child.findNodeBefore(offset);\n                }\n                return child;\n            }\n        }\n        return this;\n    };\n    Node.prototype.findNodeAt = function (offset) {\n        var idx = findFirst(this.children, function (c) { return offset <= c.start; }) - 1;\n        if (idx >= 0) {\n            var child = this.children[idx];\n            if (offset > child.start && offset <= child.end) {\n                return child.findNodeAt(offset);\n            }\n        }\n        return this;\n    };\n    return Node;\n}());\nexport { Node };\nexport function parse(text) {\n    var scanner = createScanner(text);\n    var htmlDocument = new Node(0, text.length, [], void 0);\n    var curr = htmlDocument;\n    var endTagStart = -1;\n    var endTagName = null;\n    var pendingAttribute = null;\n    var token = scanner.scan();\n    while (token !== TokenType.EOS) {\n        switch (token) {\n            case TokenType.StartTagOpen:\n                var child = new Node(scanner.getTokenOffset(), text.length, [], curr);\n                curr.children.push(child);\n                curr = child;\n                break;\n            case TokenType.StartTag:\n                curr.tag = scanner.getTokenText();\n                break;\n            case TokenType.StartTagClose:\n                curr.end = scanner.getTokenEnd(); // might be later set to end tag position\n                curr.startTagEnd = scanner.getTokenEnd();\n                if (curr.tag && isVoidElement(curr.tag) && curr.parent) {\n                    curr.closed = true;\n                    curr = curr.parent;\n                }\n                break;\n            case TokenType.StartTagSelfClose:\n                if (curr.parent) {\n                    curr.closed = true;\n                    curr.end = scanner.getTokenEnd();\n                    curr.startTagEnd = scanner.getTokenEnd();\n                    curr = curr.parent;\n                }\n                break;\n            case TokenType.EndTagOpen:\n                endTagStart = scanner.getTokenOffset();\n                endTagName = null;\n                break;\n            case TokenType.EndTag:\n                endTagName = scanner.getTokenText().toLowerCase();\n                break;\n            case TokenType.EndTagClose:\n                if (endTagName) {\n                    var node = curr;\n                    // see if we can find a matching tag\n                    while (!node.isSameTag(endTagName) && node.parent) {\n                        node = node.parent;\n                    }\n                    if (node.parent) {\n                        while (curr !== node) {\n                            curr.end = endTagStart;\n                            curr.closed = false;\n                            curr = curr.parent;\n                        }\n                        curr.closed = true;\n                        curr.endTagStart = endTagStart;\n                        curr.end = scanner.getTokenEnd();\n                        curr = curr.parent;\n                    }\n                }\n                break;\n            case TokenType.AttributeName: {\n                pendingAttribute = scanner.getTokenText();\n                var attributes = curr.attributes;\n                if (!attributes) {\n                    curr.attributes = attributes = {};\n                }\n                attributes[pendingAttribute] = null; // Support valueless attributes such as 'checked'\n                break;\n            }\n            case TokenType.AttributeValue: {\n                var value = scanner.getTokenText();\n                var attributes = curr.attributes;\n                if (attributes && pendingAttribute) {\n                    attributes[pendingAttribute] = value;\n                    pendingAttribute = null;\n                }\n                break;\n            }\n        }\n        token = scanner.scan();\n    }\n    while (curr.parent) {\n        curr.end = text.length;\n        curr.closed = false;\n        curr = curr.parent;\n    }\n    return {\n        roots: htmlDocument.children,\n        findNodeBefore: htmlDocument.findNodeBefore.bind(htmlDocument),\n        findNodeAt: htmlDocument.findNodeAt.bind(htmlDocument)\n    };\n}\n"]},"metadata":{},"sourceType":"module"}