{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as nls from './../../../fillers/vscode-nls.js';\nimport { TokenType, ScannerState } from '../htmlLanguageTypes.js';\nvar localize = nls.loadMessageBundle();\n\nvar MultiLineStream =\n/** @class */\nfunction () {\n  function MultiLineStream(source, position) {\n    this.source = source;\n    this.len = source.length;\n    this.position = position;\n  }\n\n  MultiLineStream.prototype.eos = function () {\n    return this.len <= this.position;\n  };\n\n  MultiLineStream.prototype.getSource = function () {\n    return this.source;\n  };\n\n  MultiLineStream.prototype.pos = function () {\n    return this.position;\n  };\n\n  MultiLineStream.prototype.goBackTo = function (pos) {\n    this.position = pos;\n  };\n\n  MultiLineStream.prototype.goBack = function (n) {\n    this.position -= n;\n  };\n\n  MultiLineStream.prototype.advance = function (n) {\n    this.position += n;\n  };\n\n  MultiLineStream.prototype.goToEnd = function () {\n    this.position = this.source.length;\n  };\n\n  MultiLineStream.prototype.nextChar = function () {\n    return this.source.charCodeAt(this.position++) || 0;\n  };\n\n  MultiLineStream.prototype.peekChar = function (n) {\n    if (n === void 0) {\n      n = 0;\n    }\n\n    return this.source.charCodeAt(this.position + n) || 0;\n  };\n\n  MultiLineStream.prototype.advanceIfChar = function (ch) {\n    if (ch === this.source.charCodeAt(this.position)) {\n      this.position++;\n      return true;\n    }\n\n    return false;\n  };\n\n  MultiLineStream.prototype.advanceIfChars = function (ch) {\n    var i;\n\n    if (this.position + ch.length > this.source.length) {\n      return false;\n    }\n\n    for (i = 0; i < ch.length; i++) {\n      if (this.source.charCodeAt(this.position + i) !== ch[i]) {\n        return false;\n      }\n    }\n\n    this.advance(i);\n    return true;\n  };\n\n  MultiLineStream.prototype.advanceIfRegExp = function (regex) {\n    var str = this.source.substr(this.position);\n    var match = str.match(regex);\n\n    if (match) {\n      this.position = this.position + match.index + match[0].length;\n      return match[0];\n    }\n\n    return '';\n  };\n\n  MultiLineStream.prototype.advanceUntilRegExp = function (regex) {\n    var str = this.source.substr(this.position);\n    var match = str.match(regex);\n\n    if (match) {\n      this.position = this.position + match.index;\n      return match[0];\n    } else {\n      this.goToEnd();\n    }\n\n    return '';\n  };\n\n  MultiLineStream.prototype.advanceUntilChar = function (ch) {\n    while (this.position < this.source.length) {\n      if (this.source.charCodeAt(this.position) === ch) {\n        return true;\n      }\n\n      this.advance(1);\n    }\n\n    return false;\n  };\n\n  MultiLineStream.prototype.advanceUntilChars = function (ch) {\n    while (this.position + ch.length <= this.source.length) {\n      var i = 0;\n\n      for (; i < ch.length && this.source.charCodeAt(this.position + i) === ch[i]; i++) {}\n\n      if (i === ch.length) {\n        return true;\n      }\n\n      this.advance(1);\n    }\n\n    this.goToEnd();\n    return false;\n  };\n\n  MultiLineStream.prototype.skipWhitespace = function () {\n    var n = this.advanceWhileChar(function (ch) {\n      return ch === _WSP || ch === _TAB || ch === _NWL || ch === _LFD || ch === _CAR;\n    });\n    return n > 0;\n  };\n\n  MultiLineStream.prototype.advanceWhileChar = function (condition) {\n    var posNow = this.position;\n\n    while (this.position < this.len && condition(this.source.charCodeAt(this.position))) {\n      this.position++;\n    }\n\n    return this.position - posNow;\n  };\n\n  return MultiLineStream;\n}();\n\nvar _BNG = '!'.charCodeAt(0);\n\nvar _MIN = '-'.charCodeAt(0);\n\nvar _LAN = '<'.charCodeAt(0);\n\nvar _RAN = '>'.charCodeAt(0);\n\nvar _FSL = '/'.charCodeAt(0);\n\nvar _EQS = '='.charCodeAt(0);\n\nvar _DQO = '\"'.charCodeAt(0);\n\nvar _SQO = '\\''.charCodeAt(0);\n\nvar _NWL = '\\n'.charCodeAt(0);\n\nvar _CAR = '\\r'.charCodeAt(0);\n\nvar _LFD = '\\f'.charCodeAt(0);\n\nvar _WSP = ' '.charCodeAt(0);\n\nvar _TAB = '\\t'.charCodeAt(0);\n\nvar htmlScriptContents = {\n  'text/x-handlebars-template': true\n};\nexport function createScanner(input, initialOffset, initialState) {\n  if (initialOffset === void 0) {\n    initialOffset = 0;\n  }\n\n  if (initialState === void 0) {\n    initialState = ScannerState.WithinContent;\n  }\n\n  var stream = new MultiLineStream(input, initialOffset);\n  var state = initialState;\n  var tokenOffset = 0;\n  var tokenType = TokenType.Unknown;\n  var tokenError;\n  var hasSpaceAfterTag;\n  var lastTag;\n  var lastAttributeName;\n  var lastTypeValue;\n\n  function nextElementName() {\n    return stream.advanceIfRegExp(/^[_:\\w][_:\\w-.\\d]*/).toLowerCase();\n  }\n\n  function nextAttributeName() {\n    return stream.advanceIfRegExp(/^[^\\s\"'>/=\\x00-\\x0F\\x7F\\x80-\\x9F]*/).toLowerCase();\n  }\n\n  function finishToken(offset, type, errorMessage) {\n    tokenType = type;\n    tokenOffset = offset;\n    tokenError = errorMessage;\n    return type;\n  }\n\n  function scan() {\n    var offset = stream.pos();\n    var oldState = state;\n    var token = internalScan();\n\n    if (token !== TokenType.EOS && offset === stream.pos()) {\n      console.log('Scanner.scan has not advanced at offset ' + offset + ', state before: ' + oldState + ' after: ' + state);\n      stream.advance(1);\n      return finishToken(offset, TokenType.Unknown);\n    }\n\n    return token;\n  }\n\n  function internalScan() {\n    var offset = stream.pos();\n\n    if (stream.eos()) {\n      return finishToken(offset, TokenType.EOS);\n    }\n\n    var errorMessage;\n\n    switch (state) {\n      case ScannerState.WithinComment:\n        if (stream.advanceIfChars([_MIN, _MIN, _RAN])) {\n          // -->\n          state = ScannerState.WithinContent;\n          return finishToken(offset, TokenType.EndCommentTag);\n        }\n\n        stream.advanceUntilChars([_MIN, _MIN, _RAN]); // -->\n\n        return finishToken(offset, TokenType.Comment);\n\n      case ScannerState.WithinDoctype:\n        if (stream.advanceIfChar(_RAN)) {\n          state = ScannerState.WithinContent;\n          return finishToken(offset, TokenType.EndDoctypeTag);\n        }\n\n        stream.advanceUntilChar(_RAN); // >\n\n        return finishToken(offset, TokenType.Doctype);\n\n      case ScannerState.WithinContent:\n        if (stream.advanceIfChar(_LAN)) {\n          // <\n          if (!stream.eos() && stream.peekChar() === _BNG) {\n            // !\n            if (stream.advanceIfChars([_BNG, _MIN, _MIN])) {\n              // <!--\n              state = ScannerState.WithinComment;\n              return finishToken(offset, TokenType.StartCommentTag);\n            }\n\n            if (stream.advanceIfRegExp(/^!doctype/i)) {\n              state = ScannerState.WithinDoctype;\n              return finishToken(offset, TokenType.StartDoctypeTag);\n            }\n          }\n\n          if (stream.advanceIfChar(_FSL)) {\n            // /\n            state = ScannerState.AfterOpeningEndTag;\n            return finishToken(offset, TokenType.EndTagOpen);\n          }\n\n          state = ScannerState.AfterOpeningStartTag;\n          return finishToken(offset, TokenType.StartTagOpen);\n        }\n\n        stream.advanceUntilChar(_LAN);\n        return finishToken(offset, TokenType.Content);\n\n      case ScannerState.AfterOpeningEndTag:\n        var tagName = nextElementName();\n\n        if (tagName.length > 0) {\n          state = ScannerState.WithinEndTag;\n          return finishToken(offset, TokenType.EndTag);\n        }\n\n        if (stream.skipWhitespace()) {\n          // white space is not valid here\n          return finishToken(offset, TokenType.Whitespace, localize('error.unexpectedWhitespace', 'Tag name must directly follow the open bracket.'));\n        }\n\n        state = ScannerState.WithinEndTag;\n        stream.advanceUntilChar(_RAN);\n\n        if (offset < stream.pos()) {\n          return finishToken(offset, TokenType.Unknown, localize('error.endTagNameExpected', 'End tag name expected.'));\n        }\n\n        return internalScan();\n\n      case ScannerState.WithinEndTag:\n        if (stream.skipWhitespace()) {\n          // white space is valid here\n          return finishToken(offset, TokenType.Whitespace);\n        }\n\n        if (stream.advanceIfChar(_RAN)) {\n          // >\n          state = ScannerState.WithinContent;\n          return finishToken(offset, TokenType.EndTagClose);\n        }\n\n        errorMessage = localize('error.tagNameExpected', 'Closing bracket expected.');\n        break;\n\n      case ScannerState.AfterOpeningStartTag:\n        lastTag = nextElementName();\n        lastTypeValue = void 0;\n        lastAttributeName = void 0;\n\n        if (lastTag.length > 0) {\n          hasSpaceAfterTag = false;\n          state = ScannerState.WithinTag;\n          return finishToken(offset, TokenType.StartTag);\n        }\n\n        if (stream.skipWhitespace()) {\n          // white space is not valid here\n          return finishToken(offset, TokenType.Whitespace, localize('error.unexpectedWhitespace', 'Tag name must directly follow the open bracket.'));\n        }\n\n        state = ScannerState.WithinTag;\n        stream.advanceUntilChar(_RAN);\n\n        if (offset < stream.pos()) {\n          return finishToken(offset, TokenType.Unknown, localize('error.startTagNameExpected', 'Start tag name expected.'));\n        }\n\n        return internalScan();\n\n      case ScannerState.WithinTag:\n        if (stream.skipWhitespace()) {\n          hasSpaceAfterTag = true; // remember that we have seen a whitespace\n\n          return finishToken(offset, TokenType.Whitespace);\n        }\n\n        if (hasSpaceAfterTag) {\n          lastAttributeName = nextAttributeName();\n\n          if (lastAttributeName.length > 0) {\n            state = ScannerState.AfterAttributeName;\n            hasSpaceAfterTag = false;\n            return finishToken(offset, TokenType.AttributeName);\n          }\n        }\n\n        if (stream.advanceIfChars([_FSL, _RAN])) {\n          // />\n          state = ScannerState.WithinContent;\n          return finishToken(offset, TokenType.StartTagSelfClose);\n        }\n\n        if (stream.advanceIfChar(_RAN)) {\n          // >\n          if (lastTag === 'script') {\n            if (lastTypeValue && htmlScriptContents[lastTypeValue]) {\n              // stay in html\n              state = ScannerState.WithinContent;\n            } else {\n              state = ScannerState.WithinScriptContent;\n            }\n          } else if (lastTag === 'style') {\n            state = ScannerState.WithinStyleContent;\n          } else {\n            state = ScannerState.WithinContent;\n          }\n\n          return finishToken(offset, TokenType.StartTagClose);\n        }\n\n        stream.advance(1);\n        return finishToken(offset, TokenType.Unknown, localize('error.unexpectedCharacterInTag', 'Unexpected character in tag.'));\n\n      case ScannerState.AfterAttributeName:\n        if (stream.skipWhitespace()) {\n          hasSpaceAfterTag = true;\n          return finishToken(offset, TokenType.Whitespace);\n        }\n\n        if (stream.advanceIfChar(_EQS)) {\n          state = ScannerState.BeforeAttributeValue;\n          return finishToken(offset, TokenType.DelimiterAssign);\n        }\n\n        state = ScannerState.WithinTag;\n        return internalScan();\n      // no advance yet - jump to WithinTag\n\n      case ScannerState.BeforeAttributeValue:\n        if (stream.skipWhitespace()) {\n          return finishToken(offset, TokenType.Whitespace);\n        }\n\n        var attributeValue = stream.advanceIfRegExp(/^[^\\s\"'`=<>]+/);\n\n        if (attributeValue.length > 0) {\n          if (stream.peekChar() === _RAN && stream.peekChar(-1) === _FSL) {\n            // <foo bar=http://foo/>\n            stream.goBack(1);\n            attributeValue = attributeValue.substr(0, attributeValue.length - 1);\n          }\n\n          if (lastAttributeName === 'type') {\n            lastTypeValue = attributeValue;\n          }\n\n          state = ScannerState.WithinTag;\n          hasSpaceAfterTag = false;\n          return finishToken(offset, TokenType.AttributeValue);\n        }\n\n        var ch = stream.peekChar();\n\n        if (ch === _SQO || ch === _DQO) {\n          stream.advance(1); // consume quote\n\n          if (stream.advanceUntilChar(ch)) {\n            stream.advance(1); // consume quote\n          }\n\n          if (lastAttributeName === 'type') {\n            lastTypeValue = stream.getSource().substring(offset + 1, stream.pos() - 1);\n          }\n\n          state = ScannerState.WithinTag;\n          hasSpaceAfterTag = false;\n          return finishToken(offset, TokenType.AttributeValue);\n        }\n\n        state = ScannerState.WithinTag;\n        hasSpaceAfterTag = false;\n        return internalScan();\n      // no advance yet - jump to WithinTag\n\n      case ScannerState.WithinScriptContent:\n        // see http://stackoverflow.com/questions/14574471/how-do-browsers-parse-a-script-tag-exactly\n        var sciptState = 1;\n\n        while (!stream.eos()) {\n          var match = stream.advanceIfRegExp(/<!--|-->|<\\/?script\\s*\\/?>?/i);\n\n          if (match.length === 0) {\n            stream.goToEnd();\n            return finishToken(offset, TokenType.Script);\n          } else if (match === '<!--') {\n            if (sciptState === 1) {\n              sciptState = 2;\n            }\n          } else if (match === '-->') {\n            sciptState = 1;\n          } else if (match[1] !== '/') {\n            // <script\n            if (sciptState === 2) {\n              sciptState = 3;\n            }\n          } else {\n            // </script\n            if (sciptState === 3) {\n              sciptState = 2;\n            } else {\n              stream.goBack(match.length); // to the beginning of the closing tag\n\n              break;\n            }\n          }\n        }\n\n        state = ScannerState.WithinContent;\n\n        if (offset < stream.pos()) {\n          return finishToken(offset, TokenType.Script);\n        }\n\n        return internalScan();\n      // no advance yet - jump to content\n\n      case ScannerState.WithinStyleContent:\n        stream.advanceUntilRegExp(/<\\/style/i);\n        state = ScannerState.WithinContent;\n\n        if (offset < stream.pos()) {\n          return finishToken(offset, TokenType.Styles);\n        }\n\n        return internalScan();\n      // no advance yet - jump to content\n    }\n\n    stream.advance(1);\n    state = ScannerState.WithinContent;\n    return finishToken(offset, TokenType.Unknown, errorMessage);\n  }\n\n  return {\n    scan: scan,\n    getTokenType: function () {\n      return tokenType;\n    },\n    getTokenOffset: function () {\n      return tokenOffset;\n    },\n    getTokenLength: function () {\n      return stream.pos() - tokenOffset;\n    },\n    getTokenEnd: function () {\n      return stream.pos();\n    },\n    getTokenText: function () {\n      return stream.getSource().substring(tokenOffset, stream.pos());\n    },\n    getScannerState: function () {\n      return state;\n    },\n    getTokenError: function () {\n      return tokenError;\n    }\n  };\n}","map":{"version":3,"sources":["/home/chaithra/Documents/customised/customised/node_modules/monaco-editor/esm/vs/language/html/_deps/vscode-html-languageservice/parser/htmlScanner.js"],"names":["nls","TokenType","ScannerState","localize","loadMessageBundle","MultiLineStream","source","position","len","length","prototype","eos","getSource","pos","goBackTo","goBack","n","advance","goToEnd","nextChar","charCodeAt","peekChar","advanceIfChar","ch","advanceIfChars","i","advanceIfRegExp","regex","str","substr","match","index","advanceUntilRegExp","advanceUntilChar","advanceUntilChars","skipWhitespace","advanceWhileChar","_WSP","_TAB","_NWL","_LFD","_CAR","condition","posNow","_BNG","_MIN","_LAN","_RAN","_FSL","_EQS","_DQO","_SQO","htmlScriptContents","createScanner","input","initialOffset","initialState","WithinContent","stream","state","tokenOffset","tokenType","Unknown","tokenError","hasSpaceAfterTag","lastTag","lastAttributeName","lastTypeValue","nextElementName","toLowerCase","nextAttributeName","finishToken","offset","type","errorMessage","scan","oldState","token","internalScan","EOS","console","log","WithinComment","EndCommentTag","Comment","WithinDoctype","EndDoctypeTag","Doctype","StartCommentTag","StartDoctypeTag","AfterOpeningEndTag","EndTagOpen","AfterOpeningStartTag","StartTagOpen","Content","tagName","WithinEndTag","EndTag","Whitespace","EndTagClose","WithinTag","StartTag","AfterAttributeName","AttributeName","StartTagSelfClose","WithinScriptContent","WithinStyleContent","StartTagClose","BeforeAttributeValue","DelimiterAssign","attributeValue","AttributeValue","substring","sciptState","Script","Styles","getTokenType","getTokenOffset","getTokenLength","getTokenEnd","getTokenText","getScannerState","getTokenError"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as nls from './../../../fillers/vscode-nls.js';\nimport { TokenType, ScannerState } from '../htmlLanguageTypes.js';\nvar localize = nls.loadMessageBundle();\nvar MultiLineStream = /** @class */ (function () {\n    function MultiLineStream(source, position) {\n        this.source = source;\n        this.len = source.length;\n        this.position = position;\n    }\n    MultiLineStream.prototype.eos = function () {\n        return this.len <= this.position;\n    };\n    MultiLineStream.prototype.getSource = function () {\n        return this.source;\n    };\n    MultiLineStream.prototype.pos = function () {\n        return this.position;\n    };\n    MultiLineStream.prototype.goBackTo = function (pos) {\n        this.position = pos;\n    };\n    MultiLineStream.prototype.goBack = function (n) {\n        this.position -= n;\n    };\n    MultiLineStream.prototype.advance = function (n) {\n        this.position += n;\n    };\n    MultiLineStream.prototype.goToEnd = function () {\n        this.position = this.source.length;\n    };\n    MultiLineStream.prototype.nextChar = function () {\n        return this.source.charCodeAt(this.position++) || 0;\n    };\n    MultiLineStream.prototype.peekChar = function (n) {\n        if (n === void 0) { n = 0; }\n        return this.source.charCodeAt(this.position + n) || 0;\n    };\n    MultiLineStream.prototype.advanceIfChar = function (ch) {\n        if (ch === this.source.charCodeAt(this.position)) {\n            this.position++;\n            return true;\n        }\n        return false;\n    };\n    MultiLineStream.prototype.advanceIfChars = function (ch) {\n        var i;\n        if (this.position + ch.length > this.source.length) {\n            return false;\n        }\n        for (i = 0; i < ch.length; i++) {\n            if (this.source.charCodeAt(this.position + i) !== ch[i]) {\n                return false;\n            }\n        }\n        this.advance(i);\n        return true;\n    };\n    MultiLineStream.prototype.advanceIfRegExp = function (regex) {\n        var str = this.source.substr(this.position);\n        var match = str.match(regex);\n        if (match) {\n            this.position = this.position + match.index + match[0].length;\n            return match[0];\n        }\n        return '';\n    };\n    MultiLineStream.prototype.advanceUntilRegExp = function (regex) {\n        var str = this.source.substr(this.position);\n        var match = str.match(regex);\n        if (match) {\n            this.position = this.position + match.index;\n            return match[0];\n        }\n        else {\n            this.goToEnd();\n        }\n        return '';\n    };\n    MultiLineStream.prototype.advanceUntilChar = function (ch) {\n        while (this.position < this.source.length) {\n            if (this.source.charCodeAt(this.position) === ch) {\n                return true;\n            }\n            this.advance(1);\n        }\n        return false;\n    };\n    MultiLineStream.prototype.advanceUntilChars = function (ch) {\n        while (this.position + ch.length <= this.source.length) {\n            var i = 0;\n            for (; i < ch.length && this.source.charCodeAt(this.position + i) === ch[i]; i++) {\n            }\n            if (i === ch.length) {\n                return true;\n            }\n            this.advance(1);\n        }\n        this.goToEnd();\n        return false;\n    };\n    MultiLineStream.prototype.skipWhitespace = function () {\n        var n = this.advanceWhileChar(function (ch) {\n            return ch === _WSP || ch === _TAB || ch === _NWL || ch === _LFD || ch === _CAR;\n        });\n        return n > 0;\n    };\n    MultiLineStream.prototype.advanceWhileChar = function (condition) {\n        var posNow = this.position;\n        while (this.position < this.len && condition(this.source.charCodeAt(this.position))) {\n            this.position++;\n        }\n        return this.position - posNow;\n    };\n    return MultiLineStream;\n}());\nvar _BNG = '!'.charCodeAt(0);\nvar _MIN = '-'.charCodeAt(0);\nvar _LAN = '<'.charCodeAt(0);\nvar _RAN = '>'.charCodeAt(0);\nvar _FSL = '/'.charCodeAt(0);\nvar _EQS = '='.charCodeAt(0);\nvar _DQO = '\"'.charCodeAt(0);\nvar _SQO = '\\''.charCodeAt(0);\nvar _NWL = '\\n'.charCodeAt(0);\nvar _CAR = '\\r'.charCodeAt(0);\nvar _LFD = '\\f'.charCodeAt(0);\nvar _WSP = ' '.charCodeAt(0);\nvar _TAB = '\\t'.charCodeAt(0);\nvar htmlScriptContents = {\n    'text/x-handlebars-template': true\n};\nexport function createScanner(input, initialOffset, initialState) {\n    if (initialOffset === void 0) { initialOffset = 0; }\n    if (initialState === void 0) { initialState = ScannerState.WithinContent; }\n    var stream = new MultiLineStream(input, initialOffset);\n    var state = initialState;\n    var tokenOffset = 0;\n    var tokenType = TokenType.Unknown;\n    var tokenError;\n    var hasSpaceAfterTag;\n    var lastTag;\n    var lastAttributeName;\n    var lastTypeValue;\n    function nextElementName() {\n        return stream.advanceIfRegExp(/^[_:\\w][_:\\w-.\\d]*/).toLowerCase();\n    }\n    function nextAttributeName() {\n        return stream.advanceIfRegExp(/^[^\\s\"'>/=\\x00-\\x0F\\x7F\\x80-\\x9F]*/).toLowerCase();\n    }\n    function finishToken(offset, type, errorMessage) {\n        tokenType = type;\n        tokenOffset = offset;\n        tokenError = errorMessage;\n        return type;\n    }\n    function scan() {\n        var offset = stream.pos();\n        var oldState = state;\n        var token = internalScan();\n        if (token !== TokenType.EOS && offset === stream.pos()) {\n            console.log('Scanner.scan has not advanced at offset ' + offset + ', state before: ' + oldState + ' after: ' + state);\n            stream.advance(1);\n            return finishToken(offset, TokenType.Unknown);\n        }\n        return token;\n    }\n    function internalScan() {\n        var offset = stream.pos();\n        if (stream.eos()) {\n            return finishToken(offset, TokenType.EOS);\n        }\n        var errorMessage;\n        switch (state) {\n            case ScannerState.WithinComment:\n                if (stream.advanceIfChars([_MIN, _MIN, _RAN])) { // -->\n                    state = ScannerState.WithinContent;\n                    return finishToken(offset, TokenType.EndCommentTag);\n                }\n                stream.advanceUntilChars([_MIN, _MIN, _RAN]); // -->\n                return finishToken(offset, TokenType.Comment);\n            case ScannerState.WithinDoctype:\n                if (stream.advanceIfChar(_RAN)) {\n                    state = ScannerState.WithinContent;\n                    return finishToken(offset, TokenType.EndDoctypeTag);\n                }\n                stream.advanceUntilChar(_RAN); // >\n                return finishToken(offset, TokenType.Doctype);\n            case ScannerState.WithinContent:\n                if (stream.advanceIfChar(_LAN)) { // <\n                    if (!stream.eos() && stream.peekChar() === _BNG) { // !\n                        if (stream.advanceIfChars([_BNG, _MIN, _MIN])) { // <!--\n                            state = ScannerState.WithinComment;\n                            return finishToken(offset, TokenType.StartCommentTag);\n                        }\n                        if (stream.advanceIfRegExp(/^!doctype/i)) {\n                            state = ScannerState.WithinDoctype;\n                            return finishToken(offset, TokenType.StartDoctypeTag);\n                        }\n                    }\n                    if (stream.advanceIfChar(_FSL)) { // /\n                        state = ScannerState.AfterOpeningEndTag;\n                        return finishToken(offset, TokenType.EndTagOpen);\n                    }\n                    state = ScannerState.AfterOpeningStartTag;\n                    return finishToken(offset, TokenType.StartTagOpen);\n                }\n                stream.advanceUntilChar(_LAN);\n                return finishToken(offset, TokenType.Content);\n            case ScannerState.AfterOpeningEndTag:\n                var tagName = nextElementName();\n                if (tagName.length > 0) {\n                    state = ScannerState.WithinEndTag;\n                    return finishToken(offset, TokenType.EndTag);\n                }\n                if (stream.skipWhitespace()) { // white space is not valid here\n                    return finishToken(offset, TokenType.Whitespace, localize('error.unexpectedWhitespace', 'Tag name must directly follow the open bracket.'));\n                }\n                state = ScannerState.WithinEndTag;\n                stream.advanceUntilChar(_RAN);\n                if (offset < stream.pos()) {\n                    return finishToken(offset, TokenType.Unknown, localize('error.endTagNameExpected', 'End tag name expected.'));\n                }\n                return internalScan();\n            case ScannerState.WithinEndTag:\n                if (stream.skipWhitespace()) { // white space is valid here\n                    return finishToken(offset, TokenType.Whitespace);\n                }\n                if (stream.advanceIfChar(_RAN)) { // >\n                    state = ScannerState.WithinContent;\n                    return finishToken(offset, TokenType.EndTagClose);\n                }\n                errorMessage = localize('error.tagNameExpected', 'Closing bracket expected.');\n                break;\n            case ScannerState.AfterOpeningStartTag:\n                lastTag = nextElementName();\n                lastTypeValue = void 0;\n                lastAttributeName = void 0;\n                if (lastTag.length > 0) {\n                    hasSpaceAfterTag = false;\n                    state = ScannerState.WithinTag;\n                    return finishToken(offset, TokenType.StartTag);\n                }\n                if (stream.skipWhitespace()) { // white space is not valid here\n                    return finishToken(offset, TokenType.Whitespace, localize('error.unexpectedWhitespace', 'Tag name must directly follow the open bracket.'));\n                }\n                state = ScannerState.WithinTag;\n                stream.advanceUntilChar(_RAN);\n                if (offset < stream.pos()) {\n                    return finishToken(offset, TokenType.Unknown, localize('error.startTagNameExpected', 'Start tag name expected.'));\n                }\n                return internalScan();\n            case ScannerState.WithinTag:\n                if (stream.skipWhitespace()) {\n                    hasSpaceAfterTag = true; // remember that we have seen a whitespace\n                    return finishToken(offset, TokenType.Whitespace);\n                }\n                if (hasSpaceAfterTag) {\n                    lastAttributeName = nextAttributeName();\n                    if (lastAttributeName.length > 0) {\n                        state = ScannerState.AfterAttributeName;\n                        hasSpaceAfterTag = false;\n                        return finishToken(offset, TokenType.AttributeName);\n                    }\n                }\n                if (stream.advanceIfChars([_FSL, _RAN])) { // />\n                    state = ScannerState.WithinContent;\n                    return finishToken(offset, TokenType.StartTagSelfClose);\n                }\n                if (stream.advanceIfChar(_RAN)) { // >\n                    if (lastTag === 'script') {\n                        if (lastTypeValue && htmlScriptContents[lastTypeValue]) {\n                            // stay in html\n                            state = ScannerState.WithinContent;\n                        }\n                        else {\n                            state = ScannerState.WithinScriptContent;\n                        }\n                    }\n                    else if (lastTag === 'style') {\n                        state = ScannerState.WithinStyleContent;\n                    }\n                    else {\n                        state = ScannerState.WithinContent;\n                    }\n                    return finishToken(offset, TokenType.StartTagClose);\n                }\n                stream.advance(1);\n                return finishToken(offset, TokenType.Unknown, localize('error.unexpectedCharacterInTag', 'Unexpected character in tag.'));\n            case ScannerState.AfterAttributeName:\n                if (stream.skipWhitespace()) {\n                    hasSpaceAfterTag = true;\n                    return finishToken(offset, TokenType.Whitespace);\n                }\n                if (stream.advanceIfChar(_EQS)) {\n                    state = ScannerState.BeforeAttributeValue;\n                    return finishToken(offset, TokenType.DelimiterAssign);\n                }\n                state = ScannerState.WithinTag;\n                return internalScan(); // no advance yet - jump to WithinTag\n            case ScannerState.BeforeAttributeValue:\n                if (stream.skipWhitespace()) {\n                    return finishToken(offset, TokenType.Whitespace);\n                }\n                var attributeValue = stream.advanceIfRegExp(/^[^\\s\"'`=<>]+/);\n                if (attributeValue.length > 0) {\n                    if (stream.peekChar() === _RAN && stream.peekChar(-1) === _FSL) { // <foo bar=http://foo/>\n                        stream.goBack(1);\n                        attributeValue = attributeValue.substr(0, attributeValue.length - 1);\n                    }\n                    if (lastAttributeName === 'type') {\n                        lastTypeValue = attributeValue;\n                    }\n                    state = ScannerState.WithinTag;\n                    hasSpaceAfterTag = false;\n                    return finishToken(offset, TokenType.AttributeValue);\n                }\n                var ch = stream.peekChar();\n                if (ch === _SQO || ch === _DQO) {\n                    stream.advance(1); // consume quote\n                    if (stream.advanceUntilChar(ch)) {\n                        stream.advance(1); // consume quote\n                    }\n                    if (lastAttributeName === 'type') {\n                        lastTypeValue = stream.getSource().substring(offset + 1, stream.pos() - 1);\n                    }\n                    state = ScannerState.WithinTag;\n                    hasSpaceAfterTag = false;\n                    return finishToken(offset, TokenType.AttributeValue);\n                }\n                state = ScannerState.WithinTag;\n                hasSpaceAfterTag = false;\n                return internalScan(); // no advance yet - jump to WithinTag\n            case ScannerState.WithinScriptContent:\n                // see http://stackoverflow.com/questions/14574471/how-do-browsers-parse-a-script-tag-exactly\n                var sciptState = 1;\n                while (!stream.eos()) {\n                    var match = stream.advanceIfRegExp(/<!--|-->|<\\/?script\\s*\\/?>?/i);\n                    if (match.length === 0) {\n                        stream.goToEnd();\n                        return finishToken(offset, TokenType.Script);\n                    }\n                    else if (match === '<!--') {\n                        if (sciptState === 1) {\n                            sciptState = 2;\n                        }\n                    }\n                    else if (match === '-->') {\n                        sciptState = 1;\n                    }\n                    else if (match[1] !== '/') { // <script\n                        if (sciptState === 2) {\n                            sciptState = 3;\n                        }\n                    }\n                    else { // </script\n                        if (sciptState === 3) {\n                            sciptState = 2;\n                        }\n                        else {\n                            stream.goBack(match.length); // to the beginning of the closing tag\n                            break;\n                        }\n                    }\n                }\n                state = ScannerState.WithinContent;\n                if (offset < stream.pos()) {\n                    return finishToken(offset, TokenType.Script);\n                }\n                return internalScan(); // no advance yet - jump to content\n            case ScannerState.WithinStyleContent:\n                stream.advanceUntilRegExp(/<\\/style/i);\n                state = ScannerState.WithinContent;\n                if (offset < stream.pos()) {\n                    return finishToken(offset, TokenType.Styles);\n                }\n                return internalScan(); // no advance yet - jump to content\n        }\n        stream.advance(1);\n        state = ScannerState.WithinContent;\n        return finishToken(offset, TokenType.Unknown, errorMessage);\n    }\n    return {\n        scan: scan,\n        getTokenType: function () { return tokenType; },\n        getTokenOffset: function () { return tokenOffset; },\n        getTokenLength: function () { return stream.pos() - tokenOffset; },\n        getTokenEnd: function () { return stream.pos(); },\n        getTokenText: function () { return stream.getSource().substring(tokenOffset, stream.pos()); },\n        getScannerState: function () { return state; },\n        getTokenError: function () { return tokenError; }\n    };\n}\n"]},"metadata":{},"sourceType":"module"}