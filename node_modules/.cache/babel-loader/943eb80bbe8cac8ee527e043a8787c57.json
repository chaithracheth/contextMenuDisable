{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Range, Position } from './../_deps/vscode-languageserver-types/main.js';\nimport { html_beautify } from '../beautify/beautify-html.js';\nimport { repeat } from '../utils/strings.js';\nexport function format(document, range, options) {\n  var value = document.getText();\n  var includesEnd = true;\n  var initialIndentLevel = 0;\n  var tabSize = options.tabSize || 4;\n\n  if (range) {\n    var startOffset = document.offsetAt(range.start); // include all leading whitespace iff at the beginning of the line\n\n    var extendedStart = startOffset;\n\n    while (extendedStart > 0 && isWhitespace(value, extendedStart - 1)) {\n      extendedStart--;\n    }\n\n    if (extendedStart === 0 || isEOL(value, extendedStart - 1)) {\n      startOffset = extendedStart;\n    } else {\n      // else keep at least one whitespace\n      if (extendedStart < startOffset) {\n        startOffset = extendedStart + 1;\n      }\n    } // include all following whitespace until the end of the line\n\n\n    var endOffset = document.offsetAt(range.end);\n    var extendedEnd = endOffset;\n\n    while (extendedEnd < value.length && isWhitespace(value, extendedEnd)) {\n      extendedEnd++;\n    }\n\n    if (extendedEnd === value.length || isEOL(value, extendedEnd)) {\n      endOffset = extendedEnd;\n    }\n\n    range = Range.create(document.positionAt(startOffset), document.positionAt(endOffset)); // Do not modify if substring starts in inside an element\n    // Ending inside an element is fine as it doesn't cause formatting errors\n\n    var firstHalf = value.substring(0, startOffset);\n\n    if (new RegExp(/.*[<][^>]*$/).test(firstHalf)) {\n      //return without modification\n      value = value.substring(startOffset, endOffset);\n      return [{\n        range: range,\n        newText: value\n      }];\n    }\n\n    includesEnd = endOffset === value.length;\n    value = value.substring(startOffset, endOffset);\n\n    if (startOffset !== 0) {\n      var startOfLineOffset = document.offsetAt(Position.create(range.start.line, 0));\n      initialIndentLevel = computeIndentLevel(document.getText(), startOfLineOffset, options);\n    }\n  } else {\n    range = Range.create(Position.create(0, 0), document.positionAt(value.length));\n  }\n\n  var htmlOptions = {\n    indent_size: tabSize,\n    indent_char: options.insertSpaces ? ' ' : '\\t',\n    indent_empty_lines: getFormatOption(options, 'indentEmptyLines', false),\n    wrap_line_length: getFormatOption(options, 'wrapLineLength', 120),\n    unformatted: getTagsFormatOption(options, 'unformatted', void 0),\n    content_unformatted: getTagsFormatOption(options, 'contentUnformatted', void 0),\n    indent_inner_html: getFormatOption(options, 'indentInnerHtml', false),\n    preserve_newlines: getFormatOption(options, 'preserveNewLines', true),\n    max_preserve_newlines: getFormatOption(options, 'maxPreserveNewLines', 32786),\n    indent_handlebars: getFormatOption(options, 'indentHandlebars', false),\n    end_with_newline: includesEnd && getFormatOption(options, 'endWithNewline', false),\n    extra_liners: getTagsFormatOption(options, 'extraLiners', void 0),\n    wrap_attributes: getFormatOption(options, 'wrapAttributes', 'auto'),\n    wrap_attributes_indent_size: getFormatOption(options, 'wrapAttributesIndentSize', void 0),\n    eol: '\\n'\n  };\n  var result = html_beautify(trimLeft(value), htmlOptions);\n\n  if (initialIndentLevel > 0) {\n    var indent = options.insertSpaces ? repeat(' ', tabSize * initialIndentLevel) : repeat('\\t', initialIndentLevel);\n    result = result.split('\\n').join('\\n' + indent);\n\n    if (range.start.character === 0) {\n      result = indent + result; // keep the indent\n    }\n  }\n\n  return [{\n    range: range,\n    newText: result\n  }];\n}\n\nfunction trimLeft(str) {\n  return str.replace(/^\\s+/, '');\n}\n\nfunction getFormatOption(options, key, dflt) {\n  if (options && options.hasOwnProperty(key)) {\n    var value = options[key];\n\n    if (value !== null) {\n      return value;\n    }\n  }\n\n  return dflt;\n}\n\nfunction getTagsFormatOption(options, key, dflt) {\n  var list = getFormatOption(options, key, null);\n\n  if (typeof list === 'string') {\n    if (list.length > 0) {\n      return list.split(',').map(function (t) {\n        return t.trim().toLowerCase();\n      });\n    }\n\n    return [];\n  }\n\n  return dflt;\n}\n\nfunction computeIndentLevel(content, offset, options) {\n  var i = offset;\n  var nChars = 0;\n  var tabSize = options.tabSize || 4;\n\n  while (i < content.length) {\n    var ch = content.charAt(i);\n\n    if (ch === ' ') {\n      nChars++;\n    } else if (ch === '\\t') {\n      nChars += tabSize;\n    } else {\n      break;\n    }\n\n    i++;\n  }\n\n  return Math.floor(nChars / tabSize);\n}\n\nfunction getEOL(document) {\n  var text = document.getText();\n\n  if (document.lineCount > 1) {\n    var to = document.offsetAt(Position.create(1, 0));\n    var from = to;\n\n    while (from > 0 && isEOL(text, from - 1)) {\n      from--;\n    }\n\n    return text.substr(from, to - from);\n  }\n\n  return '\\n';\n}\n\nfunction isEOL(text, offset) {\n  return '\\r\\n'.indexOf(text.charAt(offset)) !== -1;\n}\n\nfunction isWhitespace(text, offset) {\n  return ' \\t'.indexOf(text.charAt(offset)) !== -1;\n}","map":{"version":3,"sources":["/home/chaithra/Documents/customised/customised/node_modules/monaco-editor/esm/vs/language/html/_deps/vscode-html-languageservice/services/htmlFormatter.js"],"names":["Range","Position","html_beautify","repeat","format","document","range","options","value","getText","includesEnd","initialIndentLevel","tabSize","startOffset","offsetAt","start","extendedStart","isWhitespace","isEOL","endOffset","end","extendedEnd","length","create","positionAt","firstHalf","substring","RegExp","test","newText","startOfLineOffset","line","computeIndentLevel","htmlOptions","indent_size","indent_char","insertSpaces","indent_empty_lines","getFormatOption","wrap_line_length","unformatted","getTagsFormatOption","content_unformatted","indent_inner_html","preserve_newlines","max_preserve_newlines","indent_handlebars","end_with_newline","extra_liners","wrap_attributes","wrap_attributes_indent_size","eol","result","trimLeft","indent","split","join","character","str","replace","key","dflt","hasOwnProperty","list","map","t","trim","toLowerCase","content","offset","i","nChars","ch","charAt","Math","floor","getEOL","text","lineCount","to","from","substr","indexOf"],"mappings":"AAAA;;;;AAIA,SAASA,KAAT,EAAgBC,QAAhB,QAAgC,gDAAhC;AACA,SAASC,aAAT,QAA8B,8BAA9B;AACA,SAASC,MAAT,QAAuB,qBAAvB;AACA,OAAO,SAASC,MAAT,CAAgBC,QAAhB,EAA0BC,KAA1B,EAAiCC,OAAjC,EAA0C;AAC7C,MAAIC,KAAK,GAAGH,QAAQ,CAACI,OAAT,EAAZ;AACA,MAAIC,WAAW,GAAG,IAAlB;AACA,MAAIC,kBAAkB,GAAG,CAAzB;AACA,MAAIC,OAAO,GAAGL,OAAO,CAACK,OAAR,IAAmB,CAAjC;;AACA,MAAIN,KAAJ,EAAW;AACP,QAAIO,WAAW,GAAGR,QAAQ,CAACS,QAAT,CAAkBR,KAAK,CAACS,KAAxB,CAAlB,CADO,CAEP;;AACA,QAAIC,aAAa,GAAGH,WAApB;;AACA,WAAOG,aAAa,GAAG,CAAhB,IAAqBC,YAAY,CAACT,KAAD,EAAQQ,aAAa,GAAG,CAAxB,CAAxC,EAAoE;AAChEA,MAAAA,aAAa;AAChB;;AACD,QAAIA,aAAa,KAAK,CAAlB,IAAuBE,KAAK,CAACV,KAAD,EAAQQ,aAAa,GAAG,CAAxB,CAAhC,EAA4D;AACxDH,MAAAA,WAAW,GAAGG,aAAd;AACH,KAFD,MAGK;AACD;AACA,UAAIA,aAAa,GAAGH,WAApB,EAAiC;AAC7BA,QAAAA,WAAW,GAAGG,aAAa,GAAG,CAA9B;AACH;AACJ,KAfM,CAgBP;;;AACA,QAAIG,SAAS,GAAGd,QAAQ,CAACS,QAAT,CAAkBR,KAAK,CAACc,GAAxB,CAAhB;AACA,QAAIC,WAAW,GAAGF,SAAlB;;AACA,WAAOE,WAAW,GAAGb,KAAK,CAACc,MAApB,IAA8BL,YAAY,CAACT,KAAD,EAAQa,WAAR,CAAjD,EAAuE;AACnEA,MAAAA,WAAW;AACd;;AACD,QAAIA,WAAW,KAAKb,KAAK,CAACc,MAAtB,IAAgCJ,KAAK,CAACV,KAAD,EAAQa,WAAR,CAAzC,EAA+D;AAC3DF,MAAAA,SAAS,GAAGE,WAAZ;AACH;;AACDf,IAAAA,KAAK,GAAGN,KAAK,CAACuB,MAAN,CAAalB,QAAQ,CAACmB,UAAT,CAAoBX,WAApB,CAAb,EAA+CR,QAAQ,CAACmB,UAAT,CAAoBL,SAApB,CAA/C,CAAR,CAzBO,CA0BP;AACA;;AACA,QAAIM,SAAS,GAAGjB,KAAK,CAACkB,SAAN,CAAgB,CAAhB,EAAmBb,WAAnB,CAAhB;;AACA,QAAI,IAAIc,MAAJ,CAAW,aAAX,EAA0BC,IAA1B,CAA+BH,SAA/B,CAAJ,EAA+C;AAC3C;AACAjB,MAAAA,KAAK,GAAGA,KAAK,CAACkB,SAAN,CAAgBb,WAAhB,EAA6BM,SAA7B,CAAR;AACA,aAAO,CAAC;AACAb,QAAAA,KAAK,EAAEA,KADP;AAEAuB,QAAAA,OAAO,EAAErB;AAFT,OAAD,CAAP;AAIH;;AACDE,IAAAA,WAAW,GAAGS,SAAS,KAAKX,KAAK,CAACc,MAAlC;AACAd,IAAAA,KAAK,GAAGA,KAAK,CAACkB,SAAN,CAAgBb,WAAhB,EAA6BM,SAA7B,CAAR;;AACA,QAAIN,WAAW,KAAK,CAApB,EAAuB;AACnB,UAAIiB,iBAAiB,GAAGzB,QAAQ,CAACS,QAAT,CAAkBb,QAAQ,CAACsB,MAAT,CAAgBjB,KAAK,CAACS,KAAN,CAAYgB,IAA5B,EAAkC,CAAlC,CAAlB,CAAxB;AACApB,MAAAA,kBAAkB,GAAGqB,kBAAkB,CAAC3B,QAAQ,CAACI,OAAT,EAAD,EAAqBqB,iBAArB,EAAwCvB,OAAxC,CAAvC;AACH;AACJ,GA3CD,MA4CK;AACDD,IAAAA,KAAK,GAAGN,KAAK,CAACuB,MAAN,CAAatB,QAAQ,CAACsB,MAAT,CAAgB,CAAhB,EAAmB,CAAnB,CAAb,EAAoClB,QAAQ,CAACmB,UAAT,CAAoBhB,KAAK,CAACc,MAA1B,CAApC,CAAR;AACH;;AACD,MAAIW,WAAW,GAAG;AACdC,IAAAA,WAAW,EAAEtB,OADC;AAEduB,IAAAA,WAAW,EAAE5B,OAAO,CAAC6B,YAAR,GAAuB,GAAvB,GAA6B,IAF5B;AAGdC,IAAAA,kBAAkB,EAAEC,eAAe,CAAC/B,OAAD,EAAU,kBAAV,EAA8B,KAA9B,CAHrB;AAIdgC,IAAAA,gBAAgB,EAAED,eAAe,CAAC/B,OAAD,EAAU,gBAAV,EAA4B,GAA5B,CAJnB;AAKdiC,IAAAA,WAAW,EAAEC,mBAAmB,CAAClC,OAAD,EAAU,aAAV,EAAyB,KAAK,CAA9B,CALlB;AAMdmC,IAAAA,mBAAmB,EAAED,mBAAmB,CAAClC,OAAD,EAAU,oBAAV,EAAgC,KAAK,CAArC,CAN1B;AAOdoC,IAAAA,iBAAiB,EAAEL,eAAe,CAAC/B,OAAD,EAAU,iBAAV,EAA6B,KAA7B,CAPpB;AAQdqC,IAAAA,iBAAiB,EAAEN,eAAe,CAAC/B,OAAD,EAAU,kBAAV,EAA8B,IAA9B,CARpB;AASdsC,IAAAA,qBAAqB,EAAEP,eAAe,CAAC/B,OAAD,EAAU,qBAAV,EAAiC,KAAjC,CATxB;AAUduC,IAAAA,iBAAiB,EAAER,eAAe,CAAC/B,OAAD,EAAU,kBAAV,EAA8B,KAA9B,CAVpB;AAWdwC,IAAAA,gBAAgB,EAAErC,WAAW,IAAI4B,eAAe,CAAC/B,OAAD,EAAU,gBAAV,EAA4B,KAA5B,CAXlC;AAYdyC,IAAAA,YAAY,EAAEP,mBAAmB,CAAClC,OAAD,EAAU,aAAV,EAAyB,KAAK,CAA9B,CAZnB;AAad0C,IAAAA,eAAe,EAAEX,eAAe,CAAC/B,OAAD,EAAU,gBAAV,EAA4B,MAA5B,CAblB;AAcd2C,IAAAA,2BAA2B,EAAEZ,eAAe,CAAC/B,OAAD,EAAU,0BAAV,EAAsC,KAAK,CAA3C,CAd9B;AAed4C,IAAAA,GAAG,EAAE;AAfS,GAAlB;AAiBA,MAAIC,MAAM,GAAGlD,aAAa,CAACmD,QAAQ,CAAC7C,KAAD,CAAT,EAAkByB,WAAlB,CAA1B;;AACA,MAAItB,kBAAkB,GAAG,CAAzB,EAA4B;AACxB,QAAI2C,MAAM,GAAG/C,OAAO,CAAC6B,YAAR,GAAuBjC,MAAM,CAAC,GAAD,EAAMS,OAAO,GAAGD,kBAAhB,CAA7B,GAAmER,MAAM,CAAC,IAAD,EAAOQ,kBAAP,CAAtF;AACAyC,IAAAA,MAAM,GAAGA,MAAM,CAACG,KAAP,CAAa,IAAb,EAAmBC,IAAnB,CAAwB,OAAOF,MAA/B,CAAT;;AACA,QAAIhD,KAAK,CAACS,KAAN,CAAY0C,SAAZ,KAA0B,CAA9B,EAAiC;AAC7BL,MAAAA,MAAM,GAAGE,MAAM,GAAGF,MAAlB,CAD6B,CACH;AAC7B;AACJ;;AACD,SAAO,CAAC;AACA9C,IAAAA,KAAK,EAAEA,KADP;AAEAuB,IAAAA,OAAO,EAAEuB;AAFT,GAAD,CAAP;AAIH;;AACD,SAASC,QAAT,CAAkBK,GAAlB,EAAuB;AACnB,SAAOA,GAAG,CAACC,OAAJ,CAAY,MAAZ,EAAoB,EAApB,CAAP;AACH;;AACD,SAASrB,eAAT,CAAyB/B,OAAzB,EAAkCqD,GAAlC,EAAuCC,IAAvC,EAA6C;AACzC,MAAItD,OAAO,IAAIA,OAAO,CAACuD,cAAR,CAAuBF,GAAvB,CAAf,EAA4C;AACxC,QAAIpD,KAAK,GAAGD,OAAO,CAACqD,GAAD,CAAnB;;AACA,QAAIpD,KAAK,KAAK,IAAd,EAAoB;AAChB,aAAOA,KAAP;AACH;AACJ;;AACD,SAAOqD,IAAP;AACH;;AACD,SAASpB,mBAAT,CAA6BlC,OAA7B,EAAsCqD,GAAtC,EAA2CC,IAA3C,EAAiD;AAC7C,MAAIE,IAAI,GAAGzB,eAAe,CAAC/B,OAAD,EAAUqD,GAAV,EAAe,IAAf,CAA1B;;AACA,MAAI,OAAOG,IAAP,KAAgB,QAApB,EAA8B;AAC1B,QAAIA,IAAI,CAACzC,MAAL,GAAc,CAAlB,EAAqB;AACjB,aAAOyC,IAAI,CAACR,KAAL,CAAW,GAAX,EAAgBS,GAAhB,CAAoB,UAAUC,CAAV,EAAa;AAAE,eAAOA,CAAC,CAACC,IAAF,GAASC,WAAT,EAAP;AAAgC,OAAnE,CAAP;AACH;;AACD,WAAO,EAAP;AACH;;AACD,SAAON,IAAP;AACH;;AACD,SAAS7B,kBAAT,CAA4BoC,OAA5B,EAAqCC,MAArC,EAA6C9D,OAA7C,EAAsD;AAClD,MAAI+D,CAAC,GAAGD,MAAR;AACA,MAAIE,MAAM,GAAG,CAAb;AACA,MAAI3D,OAAO,GAAGL,OAAO,CAACK,OAAR,IAAmB,CAAjC;;AACA,SAAO0D,CAAC,GAAGF,OAAO,CAAC9C,MAAnB,EAA2B;AACvB,QAAIkD,EAAE,GAAGJ,OAAO,CAACK,MAAR,CAAeH,CAAf,CAAT;;AACA,QAAIE,EAAE,KAAK,GAAX,EAAgB;AACZD,MAAAA,MAAM;AACT,KAFD,MAGK,IAAIC,EAAE,KAAK,IAAX,EAAiB;AAClBD,MAAAA,MAAM,IAAI3D,OAAV;AACH,KAFI,MAGA;AACD;AACH;;AACD0D,IAAAA,CAAC;AACJ;;AACD,SAAOI,IAAI,CAACC,KAAL,CAAWJ,MAAM,GAAG3D,OAApB,CAAP;AACH;;AACD,SAASgE,MAAT,CAAgBvE,QAAhB,EAA0B;AACtB,MAAIwE,IAAI,GAAGxE,QAAQ,CAACI,OAAT,EAAX;;AACA,MAAIJ,QAAQ,CAACyE,SAAT,GAAqB,CAAzB,EAA4B;AACxB,QAAIC,EAAE,GAAG1E,QAAQ,CAACS,QAAT,CAAkBb,QAAQ,CAACsB,MAAT,CAAgB,CAAhB,EAAmB,CAAnB,CAAlB,CAAT;AACA,QAAIyD,IAAI,GAAGD,EAAX;;AACA,WAAOC,IAAI,GAAG,CAAP,IAAY9D,KAAK,CAAC2D,IAAD,EAAOG,IAAI,GAAG,CAAd,CAAxB,EAA0C;AACtCA,MAAAA,IAAI;AACP;;AACD,WAAOH,IAAI,CAACI,MAAL,CAAYD,IAAZ,EAAkBD,EAAE,GAAGC,IAAvB,CAAP;AACH;;AACD,SAAO,IAAP;AACH;;AACD,SAAS9D,KAAT,CAAe2D,IAAf,EAAqBR,MAArB,EAA6B;AACzB,SAAO,OAAOa,OAAP,CAAeL,IAAI,CAACJ,MAAL,CAAYJ,MAAZ,CAAf,MAAwC,CAAC,CAAhD;AACH;;AACD,SAASpD,YAAT,CAAsB4D,IAAtB,EAA4BR,MAA5B,EAAoC;AAChC,SAAO,MAAMa,OAAN,CAAcL,IAAI,CAACJ,MAAL,CAAYJ,MAAZ,CAAd,MAAuC,CAAC,CAA/C;AACH","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Range, Position } from './../_deps/vscode-languageserver-types/main.js';\nimport { html_beautify } from '../beautify/beautify-html.js';\nimport { repeat } from '../utils/strings.js';\nexport function format(document, range, options) {\n    var value = document.getText();\n    var includesEnd = true;\n    var initialIndentLevel = 0;\n    var tabSize = options.tabSize || 4;\n    if (range) {\n        var startOffset = document.offsetAt(range.start);\n        // include all leading whitespace iff at the beginning of the line\n        var extendedStart = startOffset;\n        while (extendedStart > 0 && isWhitespace(value, extendedStart - 1)) {\n            extendedStart--;\n        }\n        if (extendedStart === 0 || isEOL(value, extendedStart - 1)) {\n            startOffset = extendedStart;\n        }\n        else {\n            // else keep at least one whitespace\n            if (extendedStart < startOffset) {\n                startOffset = extendedStart + 1;\n            }\n        }\n        // include all following whitespace until the end of the line\n        var endOffset = document.offsetAt(range.end);\n        var extendedEnd = endOffset;\n        while (extendedEnd < value.length && isWhitespace(value, extendedEnd)) {\n            extendedEnd++;\n        }\n        if (extendedEnd === value.length || isEOL(value, extendedEnd)) {\n            endOffset = extendedEnd;\n        }\n        range = Range.create(document.positionAt(startOffset), document.positionAt(endOffset));\n        // Do not modify if substring starts in inside an element\n        // Ending inside an element is fine as it doesn't cause formatting errors\n        var firstHalf = value.substring(0, startOffset);\n        if (new RegExp(/.*[<][^>]*$/).test(firstHalf)) {\n            //return without modification\n            value = value.substring(startOffset, endOffset);\n            return [{\n                    range: range,\n                    newText: value\n                }];\n        }\n        includesEnd = endOffset === value.length;\n        value = value.substring(startOffset, endOffset);\n        if (startOffset !== 0) {\n            var startOfLineOffset = document.offsetAt(Position.create(range.start.line, 0));\n            initialIndentLevel = computeIndentLevel(document.getText(), startOfLineOffset, options);\n        }\n    }\n    else {\n        range = Range.create(Position.create(0, 0), document.positionAt(value.length));\n    }\n    var htmlOptions = {\n        indent_size: tabSize,\n        indent_char: options.insertSpaces ? ' ' : '\\t',\n        indent_empty_lines: getFormatOption(options, 'indentEmptyLines', false),\n        wrap_line_length: getFormatOption(options, 'wrapLineLength', 120),\n        unformatted: getTagsFormatOption(options, 'unformatted', void 0),\n        content_unformatted: getTagsFormatOption(options, 'contentUnformatted', void 0),\n        indent_inner_html: getFormatOption(options, 'indentInnerHtml', false),\n        preserve_newlines: getFormatOption(options, 'preserveNewLines', true),\n        max_preserve_newlines: getFormatOption(options, 'maxPreserveNewLines', 32786),\n        indent_handlebars: getFormatOption(options, 'indentHandlebars', false),\n        end_with_newline: includesEnd && getFormatOption(options, 'endWithNewline', false),\n        extra_liners: getTagsFormatOption(options, 'extraLiners', void 0),\n        wrap_attributes: getFormatOption(options, 'wrapAttributes', 'auto'),\n        wrap_attributes_indent_size: getFormatOption(options, 'wrapAttributesIndentSize', void 0),\n        eol: '\\n'\n    };\n    var result = html_beautify(trimLeft(value), htmlOptions);\n    if (initialIndentLevel > 0) {\n        var indent = options.insertSpaces ? repeat(' ', tabSize * initialIndentLevel) : repeat('\\t', initialIndentLevel);\n        result = result.split('\\n').join('\\n' + indent);\n        if (range.start.character === 0) {\n            result = indent + result; // keep the indent\n        }\n    }\n    return [{\n            range: range,\n            newText: result\n        }];\n}\nfunction trimLeft(str) {\n    return str.replace(/^\\s+/, '');\n}\nfunction getFormatOption(options, key, dflt) {\n    if (options && options.hasOwnProperty(key)) {\n        var value = options[key];\n        if (value !== null) {\n            return value;\n        }\n    }\n    return dflt;\n}\nfunction getTagsFormatOption(options, key, dflt) {\n    var list = getFormatOption(options, key, null);\n    if (typeof list === 'string') {\n        if (list.length > 0) {\n            return list.split(',').map(function (t) { return t.trim().toLowerCase(); });\n        }\n        return [];\n    }\n    return dflt;\n}\nfunction computeIndentLevel(content, offset, options) {\n    var i = offset;\n    var nChars = 0;\n    var tabSize = options.tabSize || 4;\n    while (i < content.length) {\n        var ch = content.charAt(i);\n        if (ch === ' ') {\n            nChars++;\n        }\n        else if (ch === '\\t') {\n            nChars += tabSize;\n        }\n        else {\n            break;\n        }\n        i++;\n    }\n    return Math.floor(nChars / tabSize);\n}\nfunction getEOL(document) {\n    var text = document.getText();\n    if (document.lineCount > 1) {\n        var to = document.offsetAt(Position.create(1, 0));\n        var from = to;\n        while (from > 0 && isEOL(text, from - 1)) {\n            from--;\n        }\n        return text.substr(from, to - from);\n    }\n    return '\\n';\n}\nfunction isEOL(text, offset) {\n    return '\\r\\n'.indexOf(text.charAt(offset)) !== -1;\n}\nfunction isWhitespace(text, offset) {\n    return ' \\t'.indexOf(text.charAt(offset)) !== -1;\n}\n"]},"metadata":{},"sourceType":"module"}