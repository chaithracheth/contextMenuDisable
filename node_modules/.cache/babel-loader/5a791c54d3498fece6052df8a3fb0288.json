{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { createScanner } from '../parser/htmlScanner.js';\nimport { MarkupKind } from './../_deps/vscode-languageserver-types/main.js';\nimport { TokenType } from '../htmlLanguageTypes.js';\nimport { getAllDataProviders } from '../languageFacts/builtinDataProviders.js';\nimport { isDefined } from '../utils/object.js';\nimport { generateDocumentation } from '../languageFacts/dataProvider.js';\n\nvar HTMLHover =\n/** @class */\nfunction () {\n  function HTMLHover(clientCapabilities) {\n    this.clientCapabilities = clientCapabilities;\n  }\n\n  HTMLHover.prototype.doHover = function (document, position, htmlDocument) {\n    var convertContents = this.convertContents.bind(this);\n    var doesSupportMarkdown = this.doesSupportMarkdown();\n    var offset = document.offsetAt(position);\n    var node = htmlDocument.findNodeAt(offset);\n\n    if (!node || !node.tag) {\n      return null;\n    }\n\n    var dataProviders = getAllDataProviders().filter(function (p) {\n      return p.isApplicable(document.languageId);\n    });\n\n    function getTagHover(currTag, range, open) {\n      currTag = currTag.toLowerCase();\n\n      var _loop_1 = function (provider) {\n        var hover = null;\n        provider.provideTags().forEach(function (tag) {\n          if (tag.name.toLowerCase() === currTag.toLowerCase()) {\n            var tagLabel = open ? '<' + currTag + '>' : '</' + currTag + '>';\n            var markupContent = generateDocumentation(tag, doesSupportMarkdown);\n            markupContent.value = '```html\\n' + tagLabel + '\\n```\\n' + markupContent.value;\n            hover = {\n              contents: markupContent,\n              range: range\n            };\n          }\n        });\n\n        if (hover) {\n          hover.contents = convertContents(hover.contents);\n          return {\n            value: hover\n          };\n        }\n      };\n\n      for (var _i = 0, dataProviders_1 = dataProviders; _i < dataProviders_1.length; _i++) {\n        var provider = dataProviders_1[_i];\n\n        var state_1 = _loop_1(provider);\n\n        if (typeof state_1 === \"object\") return state_1.value;\n      }\n\n      return null;\n    }\n\n    function getAttrHover(currTag, currAttr, range) {\n      currTag = currTag.toLowerCase();\n\n      var _loop_2 = function (provider) {\n        var hover = null;\n        provider.provideAttributes(currTag).forEach(function (attr) {\n          if (currAttr === attr.name && attr.description) {\n            hover = {\n              contents: generateDocumentation(attr, doesSupportMarkdown),\n              range: range\n            };\n          }\n        });\n\n        if (hover) {\n          hover.contents = convertContents(hover.contents);\n          return {\n            value: hover\n          };\n        }\n      };\n\n      for (var _i = 0, dataProviders_2 = dataProviders; _i < dataProviders_2.length; _i++) {\n        var provider = dataProviders_2[_i];\n\n        var state_2 = _loop_2(provider);\n\n        if (typeof state_2 === \"object\") return state_2.value;\n      }\n\n      return null;\n    }\n\n    function getAttrValueHover(currTag, currAttr, currAttrValue, range) {\n      currTag = currTag.toLowerCase();\n\n      var _loop_3 = function (provider) {\n        var hover = null;\n        provider.provideValues(currTag, currAttr).forEach(function (attrValue) {\n          if (currAttrValue === attrValue.name && attrValue.description) {\n            hover = {\n              contents: generateDocumentation(attrValue, doesSupportMarkdown),\n              range: range\n            };\n          }\n        });\n\n        if (hover) {\n          hover.contents = convertContents(hover.contents);\n          return {\n            value: hover\n          };\n        }\n      };\n\n      for (var _i = 0, dataProviders_3 = dataProviders; _i < dataProviders_3.length; _i++) {\n        var provider = dataProviders_3[_i];\n\n        var state_3 = _loop_3(provider);\n\n        if (typeof state_3 === \"object\") return state_3.value;\n      }\n\n      return null;\n    }\n\n    function getTagNameRange(tokenType, startOffset) {\n      var scanner = createScanner(document.getText(), startOffset);\n      var token = scanner.scan();\n\n      while (token !== TokenType.EOS && (scanner.getTokenEnd() < offset || scanner.getTokenEnd() === offset && token !== tokenType)) {\n        token = scanner.scan();\n      }\n\n      if (token === tokenType && offset <= scanner.getTokenEnd()) {\n        return {\n          start: document.positionAt(scanner.getTokenOffset()),\n          end: document.positionAt(scanner.getTokenEnd())\n        };\n      }\n\n      return null;\n    }\n\n    if (node.endTagStart && offset >= node.endTagStart) {\n      var tagRange_1 = getTagNameRange(TokenType.EndTag, node.endTagStart);\n\n      if (tagRange_1) {\n        return getTagHover(node.tag, tagRange_1, false);\n      }\n\n      return null;\n    }\n\n    var tagRange = getTagNameRange(TokenType.StartTag, node.start);\n\n    if (tagRange) {\n      return getTagHover(node.tag, tagRange, true);\n    }\n\n    var attrRange = getTagNameRange(TokenType.AttributeName, node.start);\n\n    if (attrRange) {\n      var tag = node.tag;\n      var attr = document.getText(attrRange);\n      return getAttrHover(tag, attr, attrRange);\n    }\n\n    function scanAttrAndAttrValue(nodeStart, attrValueStart) {\n      var scanner = createScanner(document.getText(), nodeStart);\n      var token = scanner.scan();\n      var prevAttr = undefined;\n\n      while (token !== TokenType.EOS && scanner.getTokenEnd() <= attrValueStart) {\n        token = scanner.scan();\n\n        if (token === TokenType.AttributeName) {\n          prevAttr = scanner.getTokenText();\n        }\n      }\n\n      return prevAttr;\n    }\n\n    var attrValueRange = getTagNameRange(TokenType.AttributeValue, node.start);\n\n    if (attrValueRange) {\n      var tag = node.tag;\n      var attrValue = trimQuotes(document.getText(attrValueRange));\n      var matchAttr = scanAttrAndAttrValue(node.start, document.offsetAt(attrValueRange.start));\n\n      if (matchAttr) {\n        return getAttrValueHover(tag, matchAttr, attrValue, attrValueRange);\n      }\n    }\n\n    return null;\n  };\n\n  HTMLHover.prototype.convertContents = function (contents) {\n    if (!this.doesSupportMarkdown()) {\n      if (typeof contents === 'string') {\n        return contents;\n      } // MarkupContent\n      else if ('kind' in contents) {\n          return {\n            kind: 'plaintext',\n            value: contents.value\n          };\n        } // MarkedString[]\n        else if (Array.isArray(contents)) {\n            contents.map(function (c) {\n              return typeof c === 'string' ? c : c.value;\n            });\n          } // MarkedString\n          else {\n              return contents.value;\n            }\n    }\n\n    return contents;\n  };\n\n  HTMLHover.prototype.doesSupportMarkdown = function () {\n    if (!isDefined(this.supportsMarkdown)) {\n      if (!isDefined(this.clientCapabilities)) {\n        this.supportsMarkdown = true;\n        return this.supportsMarkdown;\n      }\n\n      var hover = this.clientCapabilities && this.clientCapabilities.textDocument && this.clientCapabilities.textDocument.hover;\n      this.supportsMarkdown = hover && hover.contentFormat && Array.isArray(hover.contentFormat) && hover.contentFormat.indexOf(MarkupKind.Markdown) !== -1;\n    }\n\n    return this.supportsMarkdown;\n  };\n\n  return HTMLHover;\n}();\n\nexport { HTMLHover };\n\nfunction trimQuotes(s) {\n  if (s.length <= 1) {\n    return s.replace(/['\"]/, '');\n  }\n\n  if (s[0] === \"'\" || s[0] === \"\\\"\") {\n    s = s.slice(1);\n  }\n\n  if (s[s.length - 1] === \"'\" || s[s.length - 1] === \"\\\"\") {\n    s = s.slice(0, -1);\n  }\n\n  return s;\n}","map":{"version":3,"sources":["/home/chaithra/Documents/customised/customised/node_modules/monaco-editor/esm/vs/language/html/_deps/vscode-html-languageservice/services/htmlHover.js"],"names":["createScanner","MarkupKind","TokenType","getAllDataProviders","isDefined","generateDocumentation","HTMLHover","clientCapabilities","prototype","doHover","document","position","htmlDocument","convertContents","bind","doesSupportMarkdown","offset","offsetAt","node","findNodeAt","tag","dataProviders","filter","p","isApplicable","languageId","getTagHover","currTag","range","open","toLowerCase","_loop_1","provider","hover","provideTags","forEach","name","tagLabel","markupContent","value","contents","_i","dataProviders_1","length","state_1","getAttrHover","currAttr","_loop_2","provideAttributes","attr","description","dataProviders_2","state_2","getAttrValueHover","currAttrValue","_loop_3","provideValues","attrValue","dataProviders_3","state_3","getTagNameRange","tokenType","startOffset","scanner","getText","token","scan","EOS","getTokenEnd","start","positionAt","getTokenOffset","end","endTagStart","tagRange_1","EndTag","tagRange","StartTag","attrRange","AttributeName","scanAttrAndAttrValue","nodeStart","attrValueStart","prevAttr","undefined","getTokenText","attrValueRange","AttributeValue","trimQuotes","matchAttr","kind","Array","isArray","map","c","supportsMarkdown","textDocument","contentFormat","indexOf","Markdown","s","replace","slice"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { createScanner } from '../parser/htmlScanner.js';\nimport { MarkupKind } from './../_deps/vscode-languageserver-types/main.js';\nimport { TokenType } from '../htmlLanguageTypes.js';\nimport { getAllDataProviders } from '../languageFacts/builtinDataProviders.js';\nimport { isDefined } from '../utils/object.js';\nimport { generateDocumentation } from '../languageFacts/dataProvider.js';\nvar HTMLHover = /** @class */ (function () {\n    function HTMLHover(clientCapabilities) {\n        this.clientCapabilities = clientCapabilities;\n    }\n    HTMLHover.prototype.doHover = function (document, position, htmlDocument) {\n        var convertContents = this.convertContents.bind(this);\n        var doesSupportMarkdown = this.doesSupportMarkdown();\n        var offset = document.offsetAt(position);\n        var node = htmlDocument.findNodeAt(offset);\n        if (!node || !node.tag) {\n            return null;\n        }\n        var dataProviders = getAllDataProviders().filter(function (p) { return p.isApplicable(document.languageId); });\n        function getTagHover(currTag, range, open) {\n            currTag = currTag.toLowerCase();\n            var _loop_1 = function (provider) {\n                var hover = null;\n                provider.provideTags().forEach(function (tag) {\n                    if (tag.name.toLowerCase() === currTag.toLowerCase()) {\n                        var tagLabel = open ? '<' + currTag + '>' : '</' + currTag + '>';\n                        var markupContent = generateDocumentation(tag, doesSupportMarkdown);\n                        markupContent.value = '```html\\n' + tagLabel + '\\n```\\n' + markupContent.value;\n                        hover = { contents: markupContent, range: range };\n                    }\n                });\n                if (hover) {\n                    hover.contents = convertContents(hover.contents);\n                    return { value: hover };\n                }\n            };\n            for (var _i = 0, dataProviders_1 = dataProviders; _i < dataProviders_1.length; _i++) {\n                var provider = dataProviders_1[_i];\n                var state_1 = _loop_1(provider);\n                if (typeof state_1 === \"object\")\n                    return state_1.value;\n            }\n            return null;\n        }\n        function getAttrHover(currTag, currAttr, range) {\n            currTag = currTag.toLowerCase();\n            var _loop_2 = function (provider) {\n                var hover = null;\n                provider.provideAttributes(currTag).forEach(function (attr) {\n                    if (currAttr === attr.name && attr.description) {\n                        hover = { contents: generateDocumentation(attr, doesSupportMarkdown), range: range };\n                    }\n                });\n                if (hover) {\n                    hover.contents = convertContents(hover.contents);\n                    return { value: hover };\n                }\n            };\n            for (var _i = 0, dataProviders_2 = dataProviders; _i < dataProviders_2.length; _i++) {\n                var provider = dataProviders_2[_i];\n                var state_2 = _loop_2(provider);\n                if (typeof state_2 === \"object\")\n                    return state_2.value;\n            }\n            return null;\n        }\n        function getAttrValueHover(currTag, currAttr, currAttrValue, range) {\n            currTag = currTag.toLowerCase();\n            var _loop_3 = function (provider) {\n                var hover = null;\n                provider.provideValues(currTag, currAttr).forEach(function (attrValue) {\n                    if (currAttrValue === attrValue.name && attrValue.description) {\n                        hover = { contents: generateDocumentation(attrValue, doesSupportMarkdown), range: range };\n                    }\n                });\n                if (hover) {\n                    hover.contents = convertContents(hover.contents);\n                    return { value: hover };\n                }\n            };\n            for (var _i = 0, dataProviders_3 = dataProviders; _i < dataProviders_3.length; _i++) {\n                var provider = dataProviders_3[_i];\n                var state_3 = _loop_3(provider);\n                if (typeof state_3 === \"object\")\n                    return state_3.value;\n            }\n            return null;\n        }\n        function getTagNameRange(tokenType, startOffset) {\n            var scanner = createScanner(document.getText(), startOffset);\n            var token = scanner.scan();\n            while (token !== TokenType.EOS && (scanner.getTokenEnd() < offset || scanner.getTokenEnd() === offset && token !== tokenType)) {\n                token = scanner.scan();\n            }\n            if (token === tokenType && offset <= scanner.getTokenEnd()) {\n                return { start: document.positionAt(scanner.getTokenOffset()), end: document.positionAt(scanner.getTokenEnd()) };\n            }\n            return null;\n        }\n        if (node.endTagStart && offset >= node.endTagStart) {\n            var tagRange_1 = getTagNameRange(TokenType.EndTag, node.endTagStart);\n            if (tagRange_1) {\n                return getTagHover(node.tag, tagRange_1, false);\n            }\n            return null;\n        }\n        var tagRange = getTagNameRange(TokenType.StartTag, node.start);\n        if (tagRange) {\n            return getTagHover(node.tag, tagRange, true);\n        }\n        var attrRange = getTagNameRange(TokenType.AttributeName, node.start);\n        if (attrRange) {\n            var tag = node.tag;\n            var attr = document.getText(attrRange);\n            return getAttrHover(tag, attr, attrRange);\n        }\n        function scanAttrAndAttrValue(nodeStart, attrValueStart) {\n            var scanner = createScanner(document.getText(), nodeStart);\n            var token = scanner.scan();\n            var prevAttr = undefined;\n            while (token !== TokenType.EOS && (scanner.getTokenEnd() <= attrValueStart)) {\n                token = scanner.scan();\n                if (token === TokenType.AttributeName) {\n                    prevAttr = scanner.getTokenText();\n                }\n            }\n            return prevAttr;\n        }\n        var attrValueRange = getTagNameRange(TokenType.AttributeValue, node.start);\n        if (attrValueRange) {\n            var tag = node.tag;\n            var attrValue = trimQuotes(document.getText(attrValueRange));\n            var matchAttr = scanAttrAndAttrValue(node.start, document.offsetAt(attrValueRange.start));\n            if (matchAttr) {\n                return getAttrValueHover(tag, matchAttr, attrValue, attrValueRange);\n            }\n        }\n        return null;\n    };\n    HTMLHover.prototype.convertContents = function (contents) {\n        if (!this.doesSupportMarkdown()) {\n            if (typeof contents === 'string') {\n                return contents;\n            }\n            // MarkupContent\n            else if ('kind' in contents) {\n                return {\n                    kind: 'plaintext',\n                    value: contents.value\n                };\n            }\n            // MarkedString[]\n            else if (Array.isArray(contents)) {\n                contents.map(function (c) {\n                    return typeof c === 'string' ? c : c.value;\n                });\n            }\n            // MarkedString\n            else {\n                return contents.value;\n            }\n        }\n        return contents;\n    };\n    HTMLHover.prototype.doesSupportMarkdown = function () {\n        if (!isDefined(this.supportsMarkdown)) {\n            if (!isDefined(this.clientCapabilities)) {\n                this.supportsMarkdown = true;\n                return this.supportsMarkdown;\n            }\n            var hover = this.clientCapabilities && this.clientCapabilities.textDocument && this.clientCapabilities.textDocument.hover;\n            this.supportsMarkdown = hover && hover.contentFormat && Array.isArray(hover.contentFormat) && hover.contentFormat.indexOf(MarkupKind.Markdown) !== -1;\n        }\n        return this.supportsMarkdown;\n    };\n    return HTMLHover;\n}());\nexport { HTMLHover };\nfunction trimQuotes(s) {\n    if (s.length <= 1) {\n        return s.replace(/['\"]/, '');\n    }\n    if (s[0] === \"'\" || s[0] === \"\\\"\") {\n        s = s.slice(1);\n    }\n    if (s[s.length - 1] === \"'\" || s[s.length - 1] === \"\\\"\") {\n        s = s.slice(0, -1);\n    }\n    return s;\n}\n"]},"metadata":{},"sourceType":"module"}