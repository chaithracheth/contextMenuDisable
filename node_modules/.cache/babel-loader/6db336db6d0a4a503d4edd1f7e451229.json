{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { FoldingRangeKind } from './../_deps/vscode-languageserver-types/main.js';\nimport { TokenType } from '../htmlLanguageTypes.js';\nimport { createScanner } from '../parser/htmlScanner.js';\nimport { isVoidElement } from '../languageFacts/fact.js';\n\nfunction limitRanges(ranges, rangeLimit) {\n  ranges = ranges.sort(function (r1, r2) {\n    var diff = r1.startLine - r2.startLine;\n\n    if (diff === 0) {\n      diff = r1.endLine - r2.endLine;\n    }\n\n    return diff;\n  }); // compute each range's nesting level in 'nestingLevels'.\n  // count the number of ranges for each level in 'nestingLevelCounts'\n\n  var top = void 0;\n  var previous = [];\n  var nestingLevels = [];\n  var nestingLevelCounts = [];\n\n  var setNestingLevel = function (index, level) {\n    nestingLevels[index] = level;\n\n    if (level < 30) {\n      nestingLevelCounts[level] = (nestingLevelCounts[level] || 0) + 1;\n    }\n  }; // compute nesting levels and sanitize\n\n\n  for (var i = 0; i < ranges.length; i++) {\n    var entry = ranges[i];\n\n    if (!top) {\n      top = entry;\n      setNestingLevel(i, 0);\n    } else {\n      if (entry.startLine > top.startLine) {\n        if (entry.endLine <= top.endLine) {\n          previous.push(top);\n          top = entry;\n          setNestingLevel(i, previous.length);\n        } else if (entry.startLine > top.endLine) {\n          do {\n            top = previous.pop();\n          } while (top && entry.startLine > top.endLine);\n\n          if (top) {\n            previous.push(top);\n          }\n\n          top = entry;\n          setNestingLevel(i, previous.length);\n        }\n      }\n    }\n  }\n\n  var entries = 0;\n  var maxLevel = 0;\n\n  for (var i = 0; i < nestingLevelCounts.length; i++) {\n    var n = nestingLevelCounts[i];\n\n    if (n) {\n      if (n + entries > rangeLimit) {\n        maxLevel = i;\n        break;\n      }\n\n      entries += n;\n    }\n  }\n\n  var result = [];\n\n  for (var i = 0; i < ranges.length; i++) {\n    var level = nestingLevels[i];\n\n    if (typeof level === 'number') {\n      if (level < maxLevel || level === maxLevel && entries++ < rangeLimit) {\n        result.push(ranges[i]);\n      }\n    }\n  }\n\n  return result;\n}\n\nexport function getFoldingRanges(document, context) {\n  var scanner = createScanner(document.getText());\n  var token = scanner.scan();\n  var ranges = [];\n  var stack = [];\n  var lastTagName = null;\n  var prevStart = -1;\n\n  function addRange(range) {\n    ranges.push(range);\n    prevStart = range.startLine;\n  }\n\n  while (token !== TokenType.EOS) {\n    switch (token) {\n      case TokenType.StartTag:\n        {\n          var tagName = scanner.getTokenText();\n          var startLine = document.positionAt(scanner.getTokenOffset()).line;\n          stack.push({\n            startLine: startLine,\n            tagName: tagName\n          });\n          lastTagName = tagName;\n          break;\n        }\n\n      case TokenType.EndTag:\n        {\n          lastTagName = scanner.getTokenText();\n          break;\n        }\n\n      case TokenType.StartTagClose:\n        if (!lastTagName || !isVoidElement(lastTagName)) {\n          break;\n        }\n\n      // fallthrough\n\n      case TokenType.EndTagClose:\n      case TokenType.StartTagSelfClose:\n        {\n          var i = stack.length - 1;\n\n          while (i >= 0 && stack[i].tagName !== lastTagName) {\n            i--;\n          }\n\n          if (i >= 0) {\n            var stackElement = stack[i];\n            stack.length = i;\n            var line = document.positionAt(scanner.getTokenOffset()).line;\n            var startLine = stackElement.startLine;\n            var endLine = line - 1;\n\n            if (endLine > startLine && prevStart !== startLine) {\n              addRange({\n                startLine: startLine,\n                endLine: endLine\n              });\n            }\n          }\n\n          break;\n        }\n\n      case TokenType.Comment:\n        {\n          var startLine = document.positionAt(scanner.getTokenOffset()).line;\n          var text = scanner.getTokenText();\n          var m = text.match(/^\\s*#(region\\b)|(endregion\\b)/);\n\n          if (m) {\n            if (m[1]) {\n              // start pattern match\n              stack.push({\n                startLine: startLine,\n                tagName: ''\n              }); // empty tagName marks region\n            } else {\n              var i = stack.length - 1;\n\n              while (i >= 0 && stack[i].tagName.length) {\n                i--;\n              }\n\n              if (i >= 0) {\n                var stackElement = stack[i];\n                stack.length = i;\n                var endLine = startLine;\n                startLine = stackElement.startLine;\n\n                if (endLine > startLine && prevStart !== startLine) {\n                  addRange({\n                    startLine: startLine,\n                    endLine: endLine,\n                    kind: FoldingRangeKind.Region\n                  });\n                }\n              }\n            }\n          } else {\n            var endLine = document.positionAt(scanner.getTokenOffset() + scanner.getTokenLength()).line;\n\n            if (startLine < endLine) {\n              addRange({\n                startLine: startLine,\n                endLine: endLine,\n                kind: FoldingRangeKind.Comment\n              });\n            }\n          }\n\n          break;\n        }\n    }\n\n    token = scanner.scan();\n  }\n\n  var rangeLimit = context && context.rangeLimit || Number.MAX_VALUE;\n\n  if (ranges.length > rangeLimit) {\n    return limitRanges(ranges, rangeLimit);\n  }\n\n  return ranges;\n}","map":{"version":3,"sources":["/home/chaithra/Documents/customised/customised/node_modules/monaco-editor/esm/vs/language/html/_deps/vscode-html-languageservice/services/htmlFolding.js"],"names":["FoldingRangeKind","TokenType","createScanner","isVoidElement","limitRanges","ranges","rangeLimit","sort","r1","r2","diff","startLine","endLine","top","previous","nestingLevels","nestingLevelCounts","setNestingLevel","index","level","i","length","entry","push","pop","entries","maxLevel","n","result","getFoldingRanges","document","context","scanner","getText","token","scan","stack","lastTagName","prevStart","addRange","range","EOS","StartTag","tagName","getTokenText","positionAt","getTokenOffset","line","EndTag","StartTagClose","EndTagClose","StartTagSelfClose","stackElement","Comment","text","m","match","kind","Region","getTokenLength","Number","MAX_VALUE"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { FoldingRangeKind } from './../_deps/vscode-languageserver-types/main.js';\nimport { TokenType } from '../htmlLanguageTypes.js';\nimport { createScanner } from '../parser/htmlScanner.js';\nimport { isVoidElement } from '../languageFacts/fact.js';\nfunction limitRanges(ranges, rangeLimit) {\n    ranges = ranges.sort(function (r1, r2) {\n        var diff = r1.startLine - r2.startLine;\n        if (diff === 0) {\n            diff = r1.endLine - r2.endLine;\n        }\n        return diff;\n    });\n    // compute each range's nesting level in 'nestingLevels'.\n    // count the number of ranges for each level in 'nestingLevelCounts'\n    var top = void 0;\n    var previous = [];\n    var nestingLevels = [];\n    var nestingLevelCounts = [];\n    var setNestingLevel = function (index, level) {\n        nestingLevels[index] = level;\n        if (level < 30) {\n            nestingLevelCounts[level] = (nestingLevelCounts[level] || 0) + 1;\n        }\n    };\n    // compute nesting levels and sanitize\n    for (var i = 0; i < ranges.length; i++) {\n        var entry = ranges[i];\n        if (!top) {\n            top = entry;\n            setNestingLevel(i, 0);\n        }\n        else {\n            if (entry.startLine > top.startLine) {\n                if (entry.endLine <= top.endLine) {\n                    previous.push(top);\n                    top = entry;\n                    setNestingLevel(i, previous.length);\n                }\n                else if (entry.startLine > top.endLine) {\n                    do {\n                        top = previous.pop();\n                    } while (top && entry.startLine > top.endLine);\n                    if (top) {\n                        previous.push(top);\n                    }\n                    top = entry;\n                    setNestingLevel(i, previous.length);\n                }\n            }\n        }\n    }\n    var entries = 0;\n    var maxLevel = 0;\n    for (var i = 0; i < nestingLevelCounts.length; i++) {\n        var n = nestingLevelCounts[i];\n        if (n) {\n            if (n + entries > rangeLimit) {\n                maxLevel = i;\n                break;\n            }\n            entries += n;\n        }\n    }\n    var result = [];\n    for (var i = 0; i < ranges.length; i++) {\n        var level = nestingLevels[i];\n        if (typeof level === 'number') {\n            if (level < maxLevel || (level === maxLevel && entries++ < rangeLimit)) {\n                result.push(ranges[i]);\n            }\n        }\n    }\n    return result;\n}\nexport function getFoldingRanges(document, context) {\n    var scanner = createScanner(document.getText());\n    var token = scanner.scan();\n    var ranges = [];\n    var stack = [];\n    var lastTagName = null;\n    var prevStart = -1;\n    function addRange(range) {\n        ranges.push(range);\n        prevStart = range.startLine;\n    }\n    while (token !== TokenType.EOS) {\n        switch (token) {\n            case TokenType.StartTag: {\n                var tagName = scanner.getTokenText();\n                var startLine = document.positionAt(scanner.getTokenOffset()).line;\n                stack.push({ startLine: startLine, tagName: tagName });\n                lastTagName = tagName;\n                break;\n            }\n            case TokenType.EndTag: {\n                lastTagName = scanner.getTokenText();\n                break;\n            }\n            case TokenType.StartTagClose:\n                if (!lastTagName || !isVoidElement(lastTagName)) {\n                    break;\n                }\n            // fallthrough\n            case TokenType.EndTagClose:\n            case TokenType.StartTagSelfClose: {\n                var i = stack.length - 1;\n                while (i >= 0 && stack[i].tagName !== lastTagName) {\n                    i--;\n                }\n                if (i >= 0) {\n                    var stackElement = stack[i];\n                    stack.length = i;\n                    var line = document.positionAt(scanner.getTokenOffset()).line;\n                    var startLine = stackElement.startLine;\n                    var endLine = line - 1;\n                    if (endLine > startLine && prevStart !== startLine) {\n                        addRange({ startLine: startLine, endLine: endLine });\n                    }\n                }\n                break;\n            }\n            case TokenType.Comment: {\n                var startLine = document.positionAt(scanner.getTokenOffset()).line;\n                var text = scanner.getTokenText();\n                var m = text.match(/^\\s*#(region\\b)|(endregion\\b)/);\n                if (m) {\n                    if (m[1]) { // start pattern match\n                        stack.push({ startLine: startLine, tagName: '' }); // empty tagName marks region\n                    }\n                    else {\n                        var i = stack.length - 1;\n                        while (i >= 0 && stack[i].tagName.length) {\n                            i--;\n                        }\n                        if (i >= 0) {\n                            var stackElement = stack[i];\n                            stack.length = i;\n                            var endLine = startLine;\n                            startLine = stackElement.startLine;\n                            if (endLine > startLine && prevStart !== startLine) {\n                                addRange({ startLine: startLine, endLine: endLine, kind: FoldingRangeKind.Region });\n                            }\n                        }\n                    }\n                }\n                else {\n                    var endLine = document.positionAt(scanner.getTokenOffset() + scanner.getTokenLength()).line;\n                    if (startLine < endLine) {\n                        addRange({ startLine: startLine, endLine: endLine, kind: FoldingRangeKind.Comment });\n                    }\n                }\n                break;\n            }\n        }\n        token = scanner.scan();\n    }\n    var rangeLimit = context && context.rangeLimit || Number.MAX_VALUE;\n    if (ranges.length > rangeLimit) {\n        return limitRanges(ranges, rangeLimit);\n    }\n    return ranges;\n}\n"]},"metadata":{},"sourceType":"module"}