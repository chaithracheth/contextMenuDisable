{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Position, CompletionItemKind, Range, TextEdit, InsertTextFormat, MarkupKind } from './../_deps/vscode-languageserver-types/main.js';\nimport { createScanner } from '../parser/htmlScanner.js';\nimport { ScannerState, TokenType } from '../htmlLanguageTypes.js';\nimport { entities } from '../parser/htmlEntities.js';\nimport * as nls from './../../../fillers/vscode-nls.js';\nimport { isLetterOrDigit, endsWith, startsWith } from '../utils/strings.js';\nimport { getAllDataProviders } from '../languageFacts/builtinDataProviders.js';\nimport { isVoidElement } from '../languageFacts/fact.js';\nimport { isDefined } from '../utils/object.js';\nimport { generateDocumentation } from '../languageFacts/dataProvider.js';\nvar localize = nls.loadMessageBundle();\n\nvar HTMLCompletion =\n/** @class */\nfunction () {\n  function HTMLCompletion(clientCapabilities) {\n    this.clientCapabilities = clientCapabilities;\n    this.completionParticipants = [];\n  }\n\n  HTMLCompletion.prototype.setCompletionParticipants = function (registeredCompletionParticipants) {\n    this.completionParticipants = registeredCompletionParticipants || [];\n  };\n\n  HTMLCompletion.prototype.doComplete = function (document, position, htmlDocument, settings) {\n    var result = this._doComplete(document, position, htmlDocument, settings);\n\n    return this.convertCompletionList(result);\n  };\n\n  HTMLCompletion.prototype._doComplete = function (document, position, htmlDocument, settings) {\n    var result = {\n      isIncomplete: false,\n      items: []\n    };\n    var completionParticipants = this.completionParticipants;\n    var dataProviders = getAllDataProviders().filter(function (p) {\n      return p.isApplicable(document.languageId) && (!settings || settings[p.getId()] !== false);\n    });\n    var doesSupportMarkdown = this.doesSupportMarkdown();\n    var text = document.getText();\n    var offset = document.offsetAt(position);\n    var node = htmlDocument.findNodeBefore(offset);\n\n    if (!node) {\n      return result;\n    }\n\n    var scanner = createScanner(text, node.start);\n    var currentTag = '';\n    var currentAttributeName;\n\n    function getReplaceRange(replaceStart, replaceEnd) {\n      if (replaceEnd === void 0) {\n        replaceEnd = offset;\n      }\n\n      if (replaceStart > offset) {\n        replaceStart = offset;\n      }\n\n      return {\n        start: document.positionAt(replaceStart),\n        end: document.positionAt(replaceEnd)\n      };\n    }\n\n    function collectOpenTagSuggestions(afterOpenBracket, tagNameEnd) {\n      var range = getReplaceRange(afterOpenBracket, tagNameEnd);\n      dataProviders.forEach(function (provider) {\n        provider.provideTags().forEach(function (tag) {\n          result.items.push({\n            label: tag.name,\n            kind: CompletionItemKind.Property,\n            documentation: generateDocumentation(tag, doesSupportMarkdown),\n            textEdit: TextEdit.replace(range, tag.name),\n            insertTextFormat: InsertTextFormat.PlainText\n          });\n        });\n      });\n      return result;\n    }\n\n    function getLineIndent(offset) {\n      var start = offset;\n\n      while (start > 0) {\n        var ch = text.charAt(start - 1);\n\n        if (\"\\n\\r\".indexOf(ch) >= 0) {\n          return text.substring(start, offset);\n        }\n\n        if (!isWhiteSpace(ch)) {\n          return null;\n        }\n\n        start--;\n      }\n\n      return text.substring(0, offset);\n    }\n\n    function collectCloseTagSuggestions(afterOpenBracket, inOpenTag, tagNameEnd) {\n      if (tagNameEnd === void 0) {\n        tagNameEnd = offset;\n      }\n\n      var range = getReplaceRange(afterOpenBracket, tagNameEnd);\n      var closeTag = isFollowedBy(text, tagNameEnd, ScannerState.WithinEndTag, TokenType.EndTagClose) ? '' : '>';\n      var curr = node;\n\n      if (inOpenTag) {\n        curr = curr.parent; // don't suggest the own tag, it's not yet open\n      }\n\n      while (curr) {\n        var tag = curr.tag;\n\n        if (tag && (!curr.closed || curr.endTagStart && curr.endTagStart > offset)) {\n          var item = {\n            label: '/' + tag,\n            kind: CompletionItemKind.Property,\n            filterText: '/' + tag,\n            textEdit: TextEdit.replace(range, '/' + tag + closeTag),\n            insertTextFormat: InsertTextFormat.PlainText\n          };\n          var startIndent = getLineIndent(curr.start);\n          var endIndent = getLineIndent(afterOpenBracket - 1);\n\n          if (startIndent !== null && endIndent !== null && startIndent !== endIndent) {\n            var insertText = startIndent + '</' + tag + closeTag;\n            item.textEdit = TextEdit.replace(getReplaceRange(afterOpenBracket - 1 - endIndent.length), insertText);\n            item.filterText = endIndent + '</' + tag;\n          }\n\n          result.items.push(item);\n          return result;\n        }\n\n        curr = curr.parent;\n      }\n\n      if (inOpenTag) {\n        return result;\n      }\n\n      dataProviders.forEach(function (provider) {\n        provider.provideTags().forEach(function (tag) {\n          result.items.push({\n            label: '/' + tag.name,\n            kind: CompletionItemKind.Property,\n            documentation: generateDocumentation(tag, doesSupportMarkdown),\n            filterText: '/' + tag + closeTag,\n            textEdit: TextEdit.replace(range, '/' + tag + closeTag),\n            insertTextFormat: InsertTextFormat.PlainText\n          });\n        });\n      });\n      return result;\n    }\n\n    function collectAutoCloseTagSuggestion(tagCloseEnd, tag) {\n      if (settings && settings.hideAutoCompleteProposals) {\n        return result;\n      }\n\n      if (!isVoidElement(tag)) {\n        var pos = document.positionAt(tagCloseEnd);\n        result.items.push({\n          label: '</' + tag + '>',\n          kind: CompletionItemKind.Property,\n          filterText: '</' + tag + '>',\n          textEdit: TextEdit.insert(pos, '$0</' + tag + '>'),\n          insertTextFormat: InsertTextFormat.Snippet\n        });\n      }\n\n      return result;\n    }\n\n    function collectTagSuggestions(tagStart, tagEnd) {\n      collectOpenTagSuggestions(tagStart, tagEnd);\n      collectCloseTagSuggestions(tagStart, true, tagEnd);\n      return result;\n    }\n\n    function collectAttributeNameSuggestions(nameStart, nameEnd) {\n      if (nameEnd === void 0) {\n        nameEnd = offset;\n      }\n\n      var replaceEnd = offset;\n\n      while (replaceEnd < nameEnd && text[replaceEnd] !== '<') {\n        // < is a valid attribute name character, but we rather assume the attribute name ends. See #23236.\n        replaceEnd++;\n      }\n\n      var range = getReplaceRange(nameStart, replaceEnd);\n      var value = isFollowedBy(text, nameEnd, ScannerState.AfterAttributeName, TokenType.DelimiterAssign) ? '' : '=\"$1\"';\n      var tag = currentTag.toLowerCase();\n      var seenAttributes = Object.create(null);\n      dataProviders.forEach(function (provider) {\n        provider.provideAttributes(tag).forEach(function (attr) {\n          if (seenAttributes[attr.name]) {\n            return;\n          }\n\n          seenAttributes[attr.name] = true;\n          var codeSnippet = attr.name;\n          var command;\n\n          if (attr.valueSet !== 'v' && value.length) {\n            codeSnippet = codeSnippet + value;\n\n            if (attr.valueSet || attr.name === 'style') {\n              command = {\n                title: 'Suggest',\n                command: 'editor.action.triggerSuggest'\n              };\n            }\n          }\n\n          result.items.push({\n            label: attr.name,\n            kind: attr.valueSet === 'handler' ? CompletionItemKind.Function : CompletionItemKind.Value,\n            documentation: generateDocumentation(attr, doesSupportMarkdown),\n            textEdit: TextEdit.replace(range, codeSnippet),\n            insertTextFormat: InsertTextFormat.Snippet,\n            command: command\n          });\n        });\n      });\n      collectDataAttributesSuggestions(range, seenAttributes);\n      return result;\n    }\n\n    function collectDataAttributesSuggestions(range, seenAttributes) {\n      var dataAttr = 'data-';\n      var dataAttributes = {};\n      dataAttributes[dataAttr] = dataAttr + \"$1=\\\"$2\\\"\";\n\n      function addNodeDataAttributes(node) {\n        node.attributeNames.forEach(function (attr) {\n          if (startsWith(attr, dataAttr) && !dataAttributes[attr] && !seenAttributes[attr]) {\n            dataAttributes[attr] = attr + '=\"$1\"';\n          }\n        });\n        node.children.forEach(function (child) {\n          return addNodeDataAttributes(child);\n        });\n      }\n\n      if (htmlDocument) {\n        htmlDocument.roots.forEach(function (root) {\n          return addNodeDataAttributes(root);\n        });\n      }\n\n      Object.keys(dataAttributes).forEach(function (attr) {\n        return result.items.push({\n          label: attr,\n          kind: CompletionItemKind.Value,\n          textEdit: TextEdit.replace(range, dataAttributes[attr]),\n          insertTextFormat: InsertTextFormat.Snippet\n        });\n      });\n    }\n\n    function collectAttributeValueSuggestions(valueStart, valueEnd) {\n      if (valueEnd === void 0) {\n        valueEnd = offset;\n      }\n\n      var range;\n      var addQuotes;\n      var valuePrefix;\n\n      if (offset > valueStart && offset <= valueEnd && isQuote(text[valueStart])) {\n        // inside quoted attribute\n        var valueContentStart = valueStart + 1;\n        var valueContentEnd = valueEnd; // valueEnd points to the char after quote, which encloses the replace range\n\n        if (valueEnd > valueStart && text[valueEnd - 1] === text[valueStart]) {\n          valueContentEnd--;\n        }\n\n        var wsBefore = getWordStart(text, offset, valueContentStart);\n        var wsAfter = getWordEnd(text, offset, valueContentEnd);\n        range = getReplaceRange(wsBefore, wsAfter);\n        valuePrefix = offset >= valueContentStart && offset <= valueContentEnd ? text.substring(valueContentStart, offset) : '';\n        addQuotes = false;\n      } else {\n        range = getReplaceRange(valueStart, valueEnd);\n        valuePrefix = text.substring(valueStart, offset);\n        addQuotes = true;\n      }\n\n      var tag = currentTag.toLowerCase();\n      var attribute = currentAttributeName.toLowerCase();\n\n      if (completionParticipants.length > 0) {\n        var fullRange = getReplaceRange(valueStart, valueEnd);\n\n        for (var _i = 0, completionParticipants_1 = completionParticipants; _i < completionParticipants_1.length; _i++) {\n          var participant = completionParticipants_1[_i];\n\n          if (participant.onHtmlAttributeValue) {\n            participant.onHtmlAttributeValue({\n              document: document,\n              position: position,\n              tag: tag,\n              attribute: attribute,\n              value: valuePrefix,\n              range: fullRange\n            });\n          }\n        }\n      }\n\n      dataProviders.forEach(function (provider) {\n        provider.provideValues(tag, attribute).forEach(function (value) {\n          var insertText = addQuotes ? '\"' + value.name + '\"' : value.name;\n          result.items.push({\n            label: value.name,\n            filterText: insertText,\n            kind: CompletionItemKind.Unit,\n            documentation: generateDocumentation(value, doesSupportMarkdown),\n            textEdit: TextEdit.replace(range, insertText),\n            insertTextFormat: InsertTextFormat.PlainText\n          });\n        });\n      });\n      collectCharacterEntityProposals();\n      return result;\n    }\n\n    function scanNextForEndPos(nextToken) {\n      if (offset === scanner.getTokenEnd()) {\n        token = scanner.scan();\n\n        if (token === nextToken && scanner.getTokenOffset() === offset) {\n          return scanner.getTokenEnd();\n        }\n      }\n\n      return offset;\n    }\n\n    function collectInsideContent() {\n      for (var _i = 0, completionParticipants_2 = completionParticipants; _i < completionParticipants_2.length; _i++) {\n        var participant = completionParticipants_2[_i];\n\n        if (participant.onHtmlContent) {\n          participant.onHtmlContent({\n            document: document,\n            position: position\n          });\n        }\n      }\n\n      return collectCharacterEntityProposals();\n    }\n\n    function collectCharacterEntityProposals() {\n      // character entities\n      var k = offset - 1;\n      var characterStart = position.character;\n\n      while (k >= 0 && isLetterOrDigit(text, k)) {\n        k--;\n        characterStart--;\n      }\n\n      if (k >= 0 && text[k] === '&') {\n        var range = Range.create(Position.create(position.line, characterStart - 1), position);\n\n        for (var entity in entities) {\n          if (endsWith(entity, ';')) {\n            var label = '&' + entity;\n            result.items.push({\n              label: label,\n              kind: CompletionItemKind.Keyword,\n              documentation: localize('entity.propose', \"Character entity representing '\" + entities[entity] + \"'\"),\n              textEdit: TextEdit.replace(range, label),\n              insertTextFormat: InsertTextFormat.PlainText\n            });\n          }\n        }\n      }\n\n      return result;\n    }\n\n    function suggestDoctype(replaceStart, replaceEnd) {\n      var range = getReplaceRange(replaceStart, replaceEnd);\n      result.items.push({\n        label: '!DOCTYPE',\n        kind: CompletionItemKind.Property,\n        documentation: 'A preamble for an HTML document.',\n        textEdit: TextEdit.replace(range, '!DOCTYPE html>'),\n        insertTextFormat: InsertTextFormat.PlainText\n      });\n    }\n\n    var token = scanner.scan();\n\n    while (token !== TokenType.EOS && scanner.getTokenOffset() <= offset) {\n      switch (token) {\n        case TokenType.StartTagOpen:\n          if (scanner.getTokenEnd() === offset) {\n            var endPos = scanNextForEndPos(TokenType.StartTag);\n\n            if (position.line === 0) {\n              suggestDoctype(offset, endPos);\n            }\n\n            return collectTagSuggestions(offset, endPos);\n          }\n\n          break;\n\n        case TokenType.StartTag:\n          if (scanner.getTokenOffset() <= offset && offset <= scanner.getTokenEnd()) {\n            return collectOpenTagSuggestions(scanner.getTokenOffset(), scanner.getTokenEnd());\n          }\n\n          currentTag = scanner.getTokenText();\n          break;\n\n        case TokenType.AttributeName:\n          if (scanner.getTokenOffset() <= offset && offset <= scanner.getTokenEnd()) {\n            return collectAttributeNameSuggestions(scanner.getTokenOffset(), scanner.getTokenEnd());\n          }\n\n          currentAttributeName = scanner.getTokenText();\n          break;\n\n        case TokenType.DelimiterAssign:\n          if (scanner.getTokenEnd() === offset) {\n            var endPos = scanNextForEndPos(TokenType.AttributeValue);\n            return collectAttributeValueSuggestions(offset, endPos);\n          }\n\n          break;\n\n        case TokenType.AttributeValue:\n          if (scanner.getTokenOffset() <= offset && offset <= scanner.getTokenEnd()) {\n            return collectAttributeValueSuggestions(scanner.getTokenOffset(), scanner.getTokenEnd());\n          }\n\n          break;\n\n        case TokenType.Whitespace:\n          if (offset <= scanner.getTokenEnd()) {\n            switch (scanner.getScannerState()) {\n              case ScannerState.AfterOpeningStartTag:\n                var startPos = scanner.getTokenOffset();\n                var endTagPos = scanNextForEndPos(TokenType.StartTag);\n                return collectTagSuggestions(startPos, endTagPos);\n\n              case ScannerState.WithinTag:\n              case ScannerState.AfterAttributeName:\n                return collectAttributeNameSuggestions(scanner.getTokenEnd());\n\n              case ScannerState.BeforeAttributeValue:\n                return collectAttributeValueSuggestions(scanner.getTokenEnd());\n\n              case ScannerState.AfterOpeningEndTag:\n                return collectCloseTagSuggestions(scanner.getTokenOffset() - 1, false);\n\n              case ScannerState.WithinContent:\n                return collectInsideContent();\n            }\n          }\n\n          break;\n\n        case TokenType.EndTagOpen:\n          if (offset <= scanner.getTokenEnd()) {\n            var afterOpenBracket = scanner.getTokenOffset() + 1;\n            var endOffset = scanNextForEndPos(TokenType.EndTag);\n            return collectCloseTagSuggestions(afterOpenBracket, false, endOffset);\n          }\n\n          break;\n\n        case TokenType.EndTag:\n          if (offset <= scanner.getTokenEnd()) {\n            var start = scanner.getTokenOffset() - 1;\n\n            while (start >= 0) {\n              var ch = text.charAt(start);\n\n              if (ch === '/') {\n                return collectCloseTagSuggestions(start, false, scanner.getTokenEnd());\n              } else if (!isWhiteSpace(ch)) {\n                break;\n              }\n\n              start--;\n            }\n          }\n\n          break;\n\n        case TokenType.StartTagClose:\n          if (offset <= scanner.getTokenEnd()) {\n            if (currentTag) {\n              return collectAutoCloseTagSuggestion(scanner.getTokenEnd(), currentTag);\n            }\n          }\n\n          break;\n\n        case TokenType.Content:\n          if (offset <= scanner.getTokenEnd()) {\n            return collectInsideContent();\n          }\n\n          break;\n\n        default:\n          if (offset <= scanner.getTokenEnd()) {\n            return result;\n          }\n\n          break;\n      }\n\n      token = scanner.scan();\n    }\n\n    return result;\n  };\n\n  HTMLCompletion.prototype.doTagComplete = function (document, position, htmlDocument) {\n    var offset = document.offsetAt(position);\n\n    if (offset <= 0) {\n      return null;\n    }\n\n    var char = document.getText().charAt(offset - 1);\n\n    if (char === '>') {\n      var node = htmlDocument.findNodeBefore(offset);\n\n      if (node && node.tag && !isVoidElement(node.tag) && node.start < offset && (!node.endTagStart || node.endTagStart > offset)) {\n        var scanner = createScanner(document.getText(), node.start);\n        var token = scanner.scan();\n\n        while (token !== TokenType.EOS && scanner.getTokenEnd() <= offset) {\n          if (token === TokenType.StartTagClose && scanner.getTokenEnd() === offset) {\n            return \"$0</\" + node.tag + \">\";\n          }\n\n          token = scanner.scan();\n        }\n      }\n    } else if (char === '/') {\n      var node = htmlDocument.findNodeBefore(offset);\n\n      while (node && node.closed) {\n        node = node.parent;\n      }\n\n      if (node && node.tag) {\n        var scanner = createScanner(document.getText(), node.start);\n        var token = scanner.scan();\n\n        while (token !== TokenType.EOS && scanner.getTokenEnd() <= offset) {\n          if (token === TokenType.EndTagOpen && scanner.getTokenEnd() === offset) {\n            return node.tag + \">\";\n          }\n\n          token = scanner.scan();\n        }\n      }\n    }\n\n    return null;\n  };\n\n  HTMLCompletion.prototype.convertCompletionList = function (list) {\n    if (!this.doesSupportMarkdown()) {\n      list.items.forEach(function (item) {\n        if (item.documentation && typeof item.documentation !== 'string') {\n          item.documentation = {\n            kind: 'plaintext',\n            value: item.documentation.value\n          };\n        }\n      });\n    }\n\n    return list;\n  };\n\n  HTMLCompletion.prototype.doesSupportMarkdown = function () {\n    if (!isDefined(this.supportsMarkdown)) {\n      if (!isDefined(this.clientCapabilities)) {\n        this.supportsMarkdown = true;\n        return this.supportsMarkdown;\n      }\n\n      var hover = this.clientCapabilities && this.clientCapabilities.textDocument && this.clientCapabilities.textDocument.hover;\n      this.supportsMarkdown = hover && hover.contentFormat && Array.isArray(hover.contentFormat) && hover.contentFormat.indexOf(MarkupKind.Markdown) !== -1;\n    }\n\n    return this.supportsMarkdown;\n  };\n\n  return HTMLCompletion;\n}();\n\nexport { HTMLCompletion };\n\nfunction isQuote(s) {\n  return /^[\"']*$/.test(s);\n}\n\nfunction isWhiteSpace(s) {\n  return /^\\s*$/.test(s);\n}\n\nfunction isFollowedBy(s, offset, intialState, expectedToken) {\n  var scanner = createScanner(s, offset, intialState);\n  var token = scanner.scan();\n\n  while (token === TokenType.Whitespace) {\n    token = scanner.scan();\n  }\n\n  return token === expectedToken;\n}\n\nfunction getWordStart(s, offset, limit) {\n  while (offset > limit && !isWhiteSpace(s[offset - 1])) {\n    offset--;\n  }\n\n  return offset;\n}\n\nfunction getWordEnd(s, offset, limit) {\n  while (offset < limit && !isWhiteSpace(s[offset])) {\n    offset++;\n  }\n\n  return offset;\n}","map":{"version":3,"sources":["/home/chaithra/Documents/customised/customised/node_modules/monaco-editor/esm/vs/language/html/_deps/vscode-html-languageservice/services/htmlCompletion.js"],"names":["Position","CompletionItemKind","Range","TextEdit","InsertTextFormat","MarkupKind","createScanner","ScannerState","TokenType","entities","nls","isLetterOrDigit","endsWith","startsWith","getAllDataProviders","isVoidElement","isDefined","generateDocumentation","localize","loadMessageBundle","HTMLCompletion","clientCapabilities","completionParticipants","prototype","setCompletionParticipants","registeredCompletionParticipants","doComplete","document","position","htmlDocument","settings","result","_doComplete","convertCompletionList","isIncomplete","items","dataProviders","filter","p","isApplicable","languageId","getId","doesSupportMarkdown","text","getText","offset","offsetAt","node","findNodeBefore","scanner","start","currentTag","currentAttributeName","getReplaceRange","replaceStart","replaceEnd","positionAt","end","collectOpenTagSuggestions","afterOpenBracket","tagNameEnd","range","forEach","provider","provideTags","tag","push","label","name","kind","Property","documentation","textEdit","replace","insertTextFormat","PlainText","getLineIndent","ch","charAt","indexOf","substring","isWhiteSpace","collectCloseTagSuggestions","inOpenTag","closeTag","isFollowedBy","WithinEndTag","EndTagClose","curr","parent","closed","endTagStart","item","filterText","startIndent","endIndent","insertText","length","collectAutoCloseTagSuggestion","tagCloseEnd","hideAutoCompleteProposals","pos","insert","Snippet","collectTagSuggestions","tagStart","tagEnd","collectAttributeNameSuggestions","nameStart","nameEnd","value","AfterAttributeName","DelimiterAssign","toLowerCase","seenAttributes","Object","create","provideAttributes","attr","codeSnippet","command","valueSet","title","Function","Value","collectDataAttributesSuggestions","dataAttr","dataAttributes","addNodeDataAttributes","attributeNames","children","child","roots","root","keys","collectAttributeValueSuggestions","valueStart","valueEnd","addQuotes","valuePrefix","isQuote","valueContentStart","valueContentEnd","wsBefore","getWordStart","wsAfter","getWordEnd","attribute","fullRange","_i","completionParticipants_1","participant","onHtmlAttributeValue","provideValues","Unit","collectCharacterEntityProposals","scanNextForEndPos","nextToken","getTokenEnd","token","scan","getTokenOffset","collectInsideContent","completionParticipants_2","onHtmlContent","k","characterStart","character","line","entity","Keyword","suggestDoctype","EOS","StartTagOpen","endPos","StartTag","getTokenText","AttributeName","AttributeValue","Whitespace","getScannerState","AfterOpeningStartTag","startPos","endTagPos","WithinTag","BeforeAttributeValue","AfterOpeningEndTag","WithinContent","EndTagOpen","endOffset","EndTag","StartTagClose","Content","doTagComplete","char","list","supportsMarkdown","hover","textDocument","contentFormat","Array","isArray","Markdown","s","test","intialState","expectedToken","limit"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Position, CompletionItemKind, Range, TextEdit, InsertTextFormat, MarkupKind } from './../_deps/vscode-languageserver-types/main.js';\nimport { createScanner } from '../parser/htmlScanner.js';\nimport { ScannerState, TokenType } from '../htmlLanguageTypes.js';\nimport { entities } from '../parser/htmlEntities.js';\nimport * as nls from './../../../fillers/vscode-nls.js';\nimport { isLetterOrDigit, endsWith, startsWith } from '../utils/strings.js';\nimport { getAllDataProviders } from '../languageFacts/builtinDataProviders.js';\nimport { isVoidElement } from '../languageFacts/fact.js';\nimport { isDefined } from '../utils/object.js';\nimport { generateDocumentation } from '../languageFacts/dataProvider.js';\nvar localize = nls.loadMessageBundle();\nvar HTMLCompletion = /** @class */ (function () {\n    function HTMLCompletion(clientCapabilities) {\n        this.clientCapabilities = clientCapabilities;\n        this.completionParticipants = [];\n    }\n    HTMLCompletion.prototype.setCompletionParticipants = function (registeredCompletionParticipants) {\n        this.completionParticipants = registeredCompletionParticipants || [];\n    };\n    HTMLCompletion.prototype.doComplete = function (document, position, htmlDocument, settings) {\n        var result = this._doComplete(document, position, htmlDocument, settings);\n        return this.convertCompletionList(result);\n    };\n    HTMLCompletion.prototype._doComplete = function (document, position, htmlDocument, settings) {\n        var result = {\n            isIncomplete: false,\n            items: []\n        };\n        var completionParticipants = this.completionParticipants;\n        var dataProviders = getAllDataProviders().filter(function (p) { return p.isApplicable(document.languageId) && (!settings || settings[p.getId()] !== false); });\n        var doesSupportMarkdown = this.doesSupportMarkdown();\n        var text = document.getText();\n        var offset = document.offsetAt(position);\n        var node = htmlDocument.findNodeBefore(offset);\n        if (!node) {\n            return result;\n        }\n        var scanner = createScanner(text, node.start);\n        var currentTag = '';\n        var currentAttributeName;\n        function getReplaceRange(replaceStart, replaceEnd) {\n            if (replaceEnd === void 0) { replaceEnd = offset; }\n            if (replaceStart > offset) {\n                replaceStart = offset;\n            }\n            return { start: document.positionAt(replaceStart), end: document.positionAt(replaceEnd) };\n        }\n        function collectOpenTagSuggestions(afterOpenBracket, tagNameEnd) {\n            var range = getReplaceRange(afterOpenBracket, tagNameEnd);\n            dataProviders.forEach(function (provider) {\n                provider.provideTags().forEach(function (tag) {\n                    result.items.push({\n                        label: tag.name,\n                        kind: CompletionItemKind.Property,\n                        documentation: generateDocumentation(tag, doesSupportMarkdown),\n                        textEdit: TextEdit.replace(range, tag.name),\n                        insertTextFormat: InsertTextFormat.PlainText\n                    });\n                });\n            });\n            return result;\n        }\n        function getLineIndent(offset) {\n            var start = offset;\n            while (start > 0) {\n                var ch = text.charAt(start - 1);\n                if (\"\\n\\r\".indexOf(ch) >= 0) {\n                    return text.substring(start, offset);\n                }\n                if (!isWhiteSpace(ch)) {\n                    return null;\n                }\n                start--;\n            }\n            return text.substring(0, offset);\n        }\n        function collectCloseTagSuggestions(afterOpenBracket, inOpenTag, tagNameEnd) {\n            if (tagNameEnd === void 0) { tagNameEnd = offset; }\n            var range = getReplaceRange(afterOpenBracket, tagNameEnd);\n            var closeTag = isFollowedBy(text, tagNameEnd, ScannerState.WithinEndTag, TokenType.EndTagClose) ? '' : '>';\n            var curr = node;\n            if (inOpenTag) {\n                curr = curr.parent; // don't suggest the own tag, it's not yet open\n            }\n            while (curr) {\n                var tag = curr.tag;\n                if (tag && (!curr.closed || curr.endTagStart && (curr.endTagStart > offset))) {\n                    var item = {\n                        label: '/' + tag,\n                        kind: CompletionItemKind.Property,\n                        filterText: '/' + tag,\n                        textEdit: TextEdit.replace(range, '/' + tag + closeTag),\n                        insertTextFormat: InsertTextFormat.PlainText\n                    };\n                    var startIndent = getLineIndent(curr.start);\n                    var endIndent = getLineIndent(afterOpenBracket - 1);\n                    if (startIndent !== null && endIndent !== null && startIndent !== endIndent) {\n                        var insertText = startIndent + '</' + tag + closeTag;\n                        item.textEdit = TextEdit.replace(getReplaceRange(afterOpenBracket - 1 - endIndent.length), insertText);\n                        item.filterText = endIndent + '</' + tag;\n                    }\n                    result.items.push(item);\n                    return result;\n                }\n                curr = curr.parent;\n            }\n            if (inOpenTag) {\n                return result;\n            }\n            dataProviders.forEach(function (provider) {\n                provider.provideTags().forEach(function (tag) {\n                    result.items.push({\n                        label: '/' + tag.name,\n                        kind: CompletionItemKind.Property,\n                        documentation: generateDocumentation(tag, doesSupportMarkdown),\n                        filterText: '/' + tag + closeTag,\n                        textEdit: TextEdit.replace(range, '/' + tag + closeTag),\n                        insertTextFormat: InsertTextFormat.PlainText\n                    });\n                });\n            });\n            return result;\n        }\n        function collectAutoCloseTagSuggestion(tagCloseEnd, tag) {\n            if (settings && settings.hideAutoCompleteProposals) {\n                return result;\n            }\n            if (!isVoidElement(tag)) {\n                var pos = document.positionAt(tagCloseEnd);\n                result.items.push({\n                    label: '</' + tag + '>',\n                    kind: CompletionItemKind.Property,\n                    filterText: '</' + tag + '>',\n                    textEdit: TextEdit.insert(pos, '$0</' + tag + '>'),\n                    insertTextFormat: InsertTextFormat.Snippet\n                });\n            }\n            return result;\n        }\n        function collectTagSuggestions(tagStart, tagEnd) {\n            collectOpenTagSuggestions(tagStart, tagEnd);\n            collectCloseTagSuggestions(tagStart, true, tagEnd);\n            return result;\n        }\n        function collectAttributeNameSuggestions(nameStart, nameEnd) {\n            if (nameEnd === void 0) { nameEnd = offset; }\n            var replaceEnd = offset;\n            while (replaceEnd < nameEnd && text[replaceEnd] !== '<') { // < is a valid attribute name character, but we rather assume the attribute name ends. See #23236.\n                replaceEnd++;\n            }\n            var range = getReplaceRange(nameStart, replaceEnd);\n            var value = isFollowedBy(text, nameEnd, ScannerState.AfterAttributeName, TokenType.DelimiterAssign) ? '' : '=\"$1\"';\n            var tag = currentTag.toLowerCase();\n            var seenAttributes = Object.create(null);\n            dataProviders.forEach(function (provider) {\n                provider.provideAttributes(tag).forEach(function (attr) {\n                    if (seenAttributes[attr.name]) {\n                        return;\n                    }\n                    seenAttributes[attr.name] = true;\n                    var codeSnippet = attr.name;\n                    var command;\n                    if (attr.valueSet !== 'v' && value.length) {\n                        codeSnippet = codeSnippet + value;\n                        if (attr.valueSet || attr.name === 'style') {\n                            command = {\n                                title: 'Suggest',\n                                command: 'editor.action.triggerSuggest'\n                            };\n                        }\n                    }\n                    result.items.push({\n                        label: attr.name,\n                        kind: attr.valueSet === 'handler' ? CompletionItemKind.Function : CompletionItemKind.Value,\n                        documentation: generateDocumentation(attr, doesSupportMarkdown),\n                        textEdit: TextEdit.replace(range, codeSnippet),\n                        insertTextFormat: InsertTextFormat.Snippet,\n                        command: command\n                    });\n                });\n            });\n            collectDataAttributesSuggestions(range, seenAttributes);\n            return result;\n        }\n        function collectDataAttributesSuggestions(range, seenAttributes) {\n            var dataAttr = 'data-';\n            var dataAttributes = {};\n            dataAttributes[dataAttr] = dataAttr + \"$1=\\\"$2\\\"\";\n            function addNodeDataAttributes(node) {\n                node.attributeNames.forEach(function (attr) {\n                    if (startsWith(attr, dataAttr) && !dataAttributes[attr] && !seenAttributes[attr]) {\n                        dataAttributes[attr] = attr + '=\"$1\"';\n                    }\n                });\n                node.children.forEach(function (child) { return addNodeDataAttributes(child); });\n            }\n            if (htmlDocument) {\n                htmlDocument.roots.forEach(function (root) { return addNodeDataAttributes(root); });\n            }\n            Object.keys(dataAttributes).forEach(function (attr) { return result.items.push({\n                label: attr,\n                kind: CompletionItemKind.Value,\n                textEdit: TextEdit.replace(range, dataAttributes[attr]),\n                insertTextFormat: InsertTextFormat.Snippet\n            }); });\n        }\n        function collectAttributeValueSuggestions(valueStart, valueEnd) {\n            if (valueEnd === void 0) { valueEnd = offset; }\n            var range;\n            var addQuotes;\n            var valuePrefix;\n            if (offset > valueStart && offset <= valueEnd && isQuote(text[valueStart])) {\n                // inside quoted attribute\n                var valueContentStart = valueStart + 1;\n                var valueContentEnd = valueEnd;\n                // valueEnd points to the char after quote, which encloses the replace range\n                if (valueEnd > valueStart && text[valueEnd - 1] === text[valueStart]) {\n                    valueContentEnd--;\n                }\n                var wsBefore = getWordStart(text, offset, valueContentStart);\n                var wsAfter = getWordEnd(text, offset, valueContentEnd);\n                range = getReplaceRange(wsBefore, wsAfter);\n                valuePrefix = offset >= valueContentStart && offset <= valueContentEnd ? text.substring(valueContentStart, offset) : '';\n                addQuotes = false;\n            }\n            else {\n                range = getReplaceRange(valueStart, valueEnd);\n                valuePrefix = text.substring(valueStart, offset);\n                addQuotes = true;\n            }\n            var tag = currentTag.toLowerCase();\n            var attribute = currentAttributeName.toLowerCase();\n            if (completionParticipants.length > 0) {\n                var fullRange = getReplaceRange(valueStart, valueEnd);\n                for (var _i = 0, completionParticipants_1 = completionParticipants; _i < completionParticipants_1.length; _i++) {\n                    var participant = completionParticipants_1[_i];\n                    if (participant.onHtmlAttributeValue) {\n                        participant.onHtmlAttributeValue({ document: document, position: position, tag: tag, attribute: attribute, value: valuePrefix, range: fullRange });\n                    }\n                }\n            }\n            dataProviders.forEach(function (provider) {\n                provider.provideValues(tag, attribute).forEach(function (value) {\n                    var insertText = addQuotes ? '\"' + value.name + '\"' : value.name;\n                    result.items.push({\n                        label: value.name,\n                        filterText: insertText,\n                        kind: CompletionItemKind.Unit,\n                        documentation: generateDocumentation(value, doesSupportMarkdown),\n                        textEdit: TextEdit.replace(range, insertText),\n                        insertTextFormat: InsertTextFormat.PlainText\n                    });\n                });\n            });\n            collectCharacterEntityProposals();\n            return result;\n        }\n        function scanNextForEndPos(nextToken) {\n            if (offset === scanner.getTokenEnd()) {\n                token = scanner.scan();\n                if (token === nextToken && scanner.getTokenOffset() === offset) {\n                    return scanner.getTokenEnd();\n                }\n            }\n            return offset;\n        }\n        function collectInsideContent() {\n            for (var _i = 0, completionParticipants_2 = completionParticipants; _i < completionParticipants_2.length; _i++) {\n                var participant = completionParticipants_2[_i];\n                if (participant.onHtmlContent) {\n                    participant.onHtmlContent({ document: document, position: position });\n                }\n            }\n            return collectCharacterEntityProposals();\n        }\n        function collectCharacterEntityProposals() {\n            // character entities\n            var k = offset - 1;\n            var characterStart = position.character;\n            while (k >= 0 && isLetterOrDigit(text, k)) {\n                k--;\n                characterStart--;\n            }\n            if (k >= 0 && text[k] === '&') {\n                var range = Range.create(Position.create(position.line, characterStart - 1), position);\n                for (var entity in entities) {\n                    if (endsWith(entity, ';')) {\n                        var label = '&' + entity;\n                        result.items.push({\n                            label: label,\n                            kind: CompletionItemKind.Keyword,\n                            documentation: localize('entity.propose', \"Character entity representing '\" + entities[entity] + \"'\"),\n                            textEdit: TextEdit.replace(range, label),\n                            insertTextFormat: InsertTextFormat.PlainText\n                        });\n                    }\n                }\n            }\n            return result;\n        }\n        function suggestDoctype(replaceStart, replaceEnd) {\n            var range = getReplaceRange(replaceStart, replaceEnd);\n            result.items.push({\n                label: '!DOCTYPE',\n                kind: CompletionItemKind.Property,\n                documentation: 'A preamble for an HTML document.',\n                textEdit: TextEdit.replace(range, '!DOCTYPE html>'),\n                insertTextFormat: InsertTextFormat.PlainText\n            });\n        }\n        var token = scanner.scan();\n        while (token !== TokenType.EOS && scanner.getTokenOffset() <= offset) {\n            switch (token) {\n                case TokenType.StartTagOpen:\n                    if (scanner.getTokenEnd() === offset) {\n                        var endPos = scanNextForEndPos(TokenType.StartTag);\n                        if (position.line === 0) {\n                            suggestDoctype(offset, endPos);\n                        }\n                        return collectTagSuggestions(offset, endPos);\n                    }\n                    break;\n                case TokenType.StartTag:\n                    if (scanner.getTokenOffset() <= offset && offset <= scanner.getTokenEnd()) {\n                        return collectOpenTagSuggestions(scanner.getTokenOffset(), scanner.getTokenEnd());\n                    }\n                    currentTag = scanner.getTokenText();\n                    break;\n                case TokenType.AttributeName:\n                    if (scanner.getTokenOffset() <= offset && offset <= scanner.getTokenEnd()) {\n                        return collectAttributeNameSuggestions(scanner.getTokenOffset(), scanner.getTokenEnd());\n                    }\n                    currentAttributeName = scanner.getTokenText();\n                    break;\n                case TokenType.DelimiterAssign:\n                    if (scanner.getTokenEnd() === offset) {\n                        var endPos = scanNextForEndPos(TokenType.AttributeValue);\n                        return collectAttributeValueSuggestions(offset, endPos);\n                    }\n                    break;\n                case TokenType.AttributeValue:\n                    if (scanner.getTokenOffset() <= offset && offset <= scanner.getTokenEnd()) {\n                        return collectAttributeValueSuggestions(scanner.getTokenOffset(), scanner.getTokenEnd());\n                    }\n                    break;\n                case TokenType.Whitespace:\n                    if (offset <= scanner.getTokenEnd()) {\n                        switch (scanner.getScannerState()) {\n                            case ScannerState.AfterOpeningStartTag:\n                                var startPos = scanner.getTokenOffset();\n                                var endTagPos = scanNextForEndPos(TokenType.StartTag);\n                                return collectTagSuggestions(startPos, endTagPos);\n                            case ScannerState.WithinTag:\n                            case ScannerState.AfterAttributeName:\n                                return collectAttributeNameSuggestions(scanner.getTokenEnd());\n                            case ScannerState.BeforeAttributeValue:\n                                return collectAttributeValueSuggestions(scanner.getTokenEnd());\n                            case ScannerState.AfterOpeningEndTag:\n                                return collectCloseTagSuggestions(scanner.getTokenOffset() - 1, false);\n                            case ScannerState.WithinContent:\n                                return collectInsideContent();\n                        }\n                    }\n                    break;\n                case TokenType.EndTagOpen:\n                    if (offset <= scanner.getTokenEnd()) {\n                        var afterOpenBracket = scanner.getTokenOffset() + 1;\n                        var endOffset = scanNextForEndPos(TokenType.EndTag);\n                        return collectCloseTagSuggestions(afterOpenBracket, false, endOffset);\n                    }\n                    break;\n                case TokenType.EndTag:\n                    if (offset <= scanner.getTokenEnd()) {\n                        var start = scanner.getTokenOffset() - 1;\n                        while (start >= 0) {\n                            var ch = text.charAt(start);\n                            if (ch === '/') {\n                                return collectCloseTagSuggestions(start, false, scanner.getTokenEnd());\n                            }\n                            else if (!isWhiteSpace(ch)) {\n                                break;\n                            }\n                            start--;\n                        }\n                    }\n                    break;\n                case TokenType.StartTagClose:\n                    if (offset <= scanner.getTokenEnd()) {\n                        if (currentTag) {\n                            return collectAutoCloseTagSuggestion(scanner.getTokenEnd(), currentTag);\n                        }\n                    }\n                    break;\n                case TokenType.Content:\n                    if (offset <= scanner.getTokenEnd()) {\n                        return collectInsideContent();\n                    }\n                    break;\n                default:\n                    if (offset <= scanner.getTokenEnd()) {\n                        return result;\n                    }\n                    break;\n            }\n            token = scanner.scan();\n        }\n        return result;\n    };\n    HTMLCompletion.prototype.doTagComplete = function (document, position, htmlDocument) {\n        var offset = document.offsetAt(position);\n        if (offset <= 0) {\n            return null;\n        }\n        var char = document.getText().charAt(offset - 1);\n        if (char === '>') {\n            var node = htmlDocument.findNodeBefore(offset);\n            if (node && node.tag && !isVoidElement(node.tag) && node.start < offset && (!node.endTagStart || node.endTagStart > offset)) {\n                var scanner = createScanner(document.getText(), node.start);\n                var token = scanner.scan();\n                while (token !== TokenType.EOS && scanner.getTokenEnd() <= offset) {\n                    if (token === TokenType.StartTagClose && scanner.getTokenEnd() === offset) {\n                        return \"$0</\" + node.tag + \">\";\n                    }\n                    token = scanner.scan();\n                }\n            }\n        }\n        else if (char === '/') {\n            var node = htmlDocument.findNodeBefore(offset);\n            while (node && node.closed) {\n                node = node.parent;\n            }\n            if (node && node.tag) {\n                var scanner = createScanner(document.getText(), node.start);\n                var token = scanner.scan();\n                while (token !== TokenType.EOS && scanner.getTokenEnd() <= offset) {\n                    if (token === TokenType.EndTagOpen && scanner.getTokenEnd() === offset) {\n                        return node.tag + \">\";\n                    }\n                    token = scanner.scan();\n                }\n            }\n        }\n        return null;\n    };\n    HTMLCompletion.prototype.convertCompletionList = function (list) {\n        if (!this.doesSupportMarkdown()) {\n            list.items.forEach(function (item) {\n                if (item.documentation && typeof item.documentation !== 'string') {\n                    item.documentation = {\n                        kind: 'plaintext',\n                        value: item.documentation.value\n                    };\n                }\n            });\n        }\n        return list;\n    };\n    HTMLCompletion.prototype.doesSupportMarkdown = function () {\n        if (!isDefined(this.supportsMarkdown)) {\n            if (!isDefined(this.clientCapabilities)) {\n                this.supportsMarkdown = true;\n                return this.supportsMarkdown;\n            }\n            var hover = this.clientCapabilities && this.clientCapabilities.textDocument && this.clientCapabilities.textDocument.hover;\n            this.supportsMarkdown = hover && hover.contentFormat && Array.isArray(hover.contentFormat) && hover.contentFormat.indexOf(MarkupKind.Markdown) !== -1;\n        }\n        return this.supportsMarkdown;\n    };\n    return HTMLCompletion;\n}());\nexport { HTMLCompletion };\nfunction isQuote(s) {\n    return /^[\"']*$/.test(s);\n}\nfunction isWhiteSpace(s) {\n    return /^\\s*$/.test(s);\n}\nfunction isFollowedBy(s, offset, intialState, expectedToken) {\n    var scanner = createScanner(s, offset, intialState);\n    var token = scanner.scan();\n    while (token === TokenType.Whitespace) {\n        token = scanner.scan();\n    }\n    return token === expectedToken;\n}\nfunction getWordStart(s, offset, limit) {\n    while (offset > limit && !isWhiteSpace(s[offset - 1])) {\n        offset--;\n    }\n    return offset;\n}\nfunction getWordEnd(s, offset, limit) {\n    while (offset < limit && !isWhiteSpace(s[offset])) {\n        offset++;\n    }\n    return offset;\n}\n"]},"metadata":{},"sourceType":"module"}